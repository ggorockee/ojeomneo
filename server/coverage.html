
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ggorockee/ojeomneo/server/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">github.com/ggorockee/ojeomneo/server/docs/docs.go (0.0%)</option>
				
				<option value="file2">github.com/ggorockee/ojeomneo/server/internal/config/config.go (0.0%)</option>
				
				<option value="file3">github.com/ggorockee/ojeomneo/server/internal/config/database.go (0.0%)</option>
				
				<option value="file4">github.com/ggorockee/ojeomneo/server/internal/config/redis.go (0.0%)</option>
				
				<option value="file5">github.com/ggorockee/ojeomneo/server/internal/handler/error.go (0.0%)</option>
				
				<option value="file6">github.com/ggorockee/ojeomneo/server/internal/handler/health.go (0.0%)</option>
				
				<option value="file7">github.com/ggorockee/ojeomneo/server/internal/handler/menu.go (88.0%)</option>
				
				<option value="file8">github.com/ggorockee/ojeomneo/server/internal/handler/sketch.go (83.3%)</option>
				
				<option value="file9">github.com/ggorockee/ojeomneo/server/internal/middleware/cache.go (0.0%)</option>
				
				<option value="file10">github.com/ggorockee/ojeomneo/server/internal/middleware/prometheus.go (0.0%)</option>
				
				<option value="file11">github.com/ggorockee/ojeomneo/server/internal/middleware/ratelimit.go (0.0%)</option>
				
				<option value="file12">github.com/ggorockee/ojeomneo/server/internal/model/menu.go (52.4%)</option>
				
				<option value="file13">github.com/ggorockee/ojeomneo/server/internal/model/recommendation.go (20.0%)</option>
				
				<option value="file14">github.com/ggorockee/ojeomneo/server/internal/model/sketch.go (40.0%)</option>
				
				<option value="file15">github.com/ggorockee/ojeomneo/server/internal/model/user.go (20.0%)</option>
				
				<option value="file16">github.com/ggorockee/ojeomneo/server/internal/seed/menu.go (0.0%)</option>
				
				<option value="file17">github.com/ggorockee/ojeomneo/server/internal/service/llm/gemini.go (17.6%)</option>
				
				<option value="file18">github.com/ggorockee/ojeomneo/server/internal/service/menu.go (58.6%)</option>
				
				<option value="file19">github.com/ggorockee/ojeomneo/server/internal/service/sketch.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "log"
        "os"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"
        "github.com/joho/godotenv"

        "github.com/ggorockee/ojeomneo/server/internal/config"
        "github.com/ggorockee/ojeomneo/server/internal/handler"
        "github.com/ggorockee/ojeomneo/server/internal/middleware"
        "github.com/ggorockee/ojeomneo/server/internal/model"
        "github.com/ggorockee/ojeomneo/server/internal/seed"
        "github.com/ggorockee/ojeomneo/server/internal/service"
        "github.com/ggorockee/ojeomneo/server/internal/service/llm"

        _ "github.com/ggorockee/ojeomneo/server/docs"
)

// @title Ojeomneo API
// @version 1.0.0
// @description Go Fiber v2 ê¸°ë°˜ REST API ì„œë²„ - ìŠ¤ì¼€ì¹˜ ê¸°ë°˜ ë©”ë‰´ ì¶”ì²œ
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.email support@woohalabs.com

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host api.woohalabs.com
// @BasePath /ojeomneo/v1

// @schemes https http
func main() <span class="cov0" title="0">{
        // .env íŒŒì¼ ë¡œë“œ
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Println("Warning: .env file not found, using environment variables")
        }</span>

        // ì„¤ì • ë¡œë“œ
        <span class="cov0" title="0">cfg := config.Load()

        // ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
        db, err := config.ConnectDB(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to connect to database: %v", err)
                log.Println("Server will start without database connection")
        }</span>

        // AutoMigrate (ìŠ¤í‚¤ë§ˆ ë™ê¸°í™”)
        <span class="cov0" title="0">if db != nil </span><span class="cov0" title="0">{
                log.Println("Running database migrations...")
                if err := db.AutoMigrate(
                        &amp;model.User{},
                        &amp;model.Menu{},
                        &amp;model.Sketch{},
                        &amp;model.Recommendation{},
                ); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to run migrations: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        log.Println("Database migrations completed")
                }</span>

                // ë©”ë‰´ ì‹œë“œ ë°ì´í„° ì‚½ì… (SEED_DATA=true ì¼ ë•Œë§Œ)
                <span class="cov0" title="0">if os.Getenv("SEED_DATA") == "true" </span><span class="cov0" title="0">{
                        log.Println("Seeding menu data...")
                        if err := seed.SeedMenus(db); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Warning: Failed to seed menus: %v", err)
                        }</span>
                }
        }

        // Redis ì—°ê²°
        <span class="cov0" title="0">rdb, err := config.ConnectRedis(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Warning: Failed to connect to redis: %v", err)
                log.Println("Server will start without redis connection")
        }</span> else<span class="cov0" title="0"> {
                log.Println("Redis connection established")
                defer rdb.Close()
        }</span>

        // LLM í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” (Gemini)
        <span class="cov0" title="0">llmClient := llm.NewClient(cfg.GeminiAPIKey, cfg.GeminiModel)
        if llmClient.IsAvailable() </span><span class="cov0" title="0">{
                log.Printf("Gemini client initialized (model: %s)", cfg.GeminiModel)
        }</span> else<span class="cov0" title="0"> {
                log.Println("Warning: Gemini API key not configured, using mock responses")
        }</span>

        // ì„œë¹„ìŠ¤ ì´ˆê¸°í™”
        <span class="cov0" title="0">menuService := service.NewMenuService(db)
        sketchService := service.NewSketchService(db, llmClient, menuService)

        // Fiber ì•± ìƒì„±
        app := fiber.New(fiber.Config{
                AppName:      "Ojeomneo API v1.0.0",
                ServerHeader: "Ojeomneo",
                ErrorHandler: handler.CustomErrorHandler,
                BodyLimit:    10 * 1024 * 1024, // 10MB (ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ ì—…ë¡œë“œìš©)
        })

        // ì „ì—­ ë¯¸ë“¤ì›¨ì–´ ì„¤ì •
        app.Use(recover.New())
        app.Use(logger.New(logger.Config{
                Format:     "${time} | ${status} | ${latency} | ${ip} | ${method} | ${path}\n",
                TimeFormat: "2006-01-02 15:04:05",
        }))
        app.Use(cors.New(cors.Config{
                AllowOrigins: "*",
                AllowMethods: "GET,POST,PUT,DELETE,PATCH,OPTIONS",
                AllowHeaders: "Origin,Content-Type,Accept,Authorization",
        }))

        // ============================================
        // /ojeomneo ê·¸ë£¹ (Ingressì—ì„œ ì „ë‹¬ë°›ëŠ” prefix)
        // Swagger ì •ì  íŒŒì¼ ë¡œë”© ë¬¸ì œ ë°©ì§€ë¥¼ ìœ„í•´ Fiberì—ì„œ ì „ì²´ ê²½ë¡œ ì²˜ë¦¬
        // ============================================
        ojeomneo := app.Group("/ojeomneo")

        // Prometheus ë©”íŠ¸ë¦­ (ë‚´ë¶€ë§ ì ‘ê·¼ ì œí•œ)
        ojeomneo.Get("/metrics", middleware.InternalOnly(), middleware.PrometheusHandler())

        // API v1 ë¼ìš°í„°
        v1 := ojeomneo.Group("/v1")

        // Rate Limiting ë¯¸ë“¤ì›¨ì–´ (Redis ì—°ê²° ì‹œì—ë§Œ í™œì„±í™”)
        if rdb != nil </span><span class="cov0" title="0">{
                rateLimitCfg := middleware.DefaultRateLimitConfig()
                rateLimitCfg.RedisClient = rdb
                v1.Use(middleware.RateLimiter(rateLimitCfg))
                log.Println("Rate Limiting middleware enabled")
        }</span>

        // API ìºì‹± ë¯¸ë“¤ì›¨ì–´ (Redis ì—°ê²° ì‹œì—ë§Œ í™œì„±í™”)
        <span class="cov0" title="0">if rdb != nil </span><span class="cov0" title="0">{
                cacheCfg := middleware.DefaultCacheConfig()
                cacheCfg.RedisClient = rdb
                v1.Use(middleware.Cache(cacheCfg))
                log.Println("API Cache middleware enabled")
        }</span>

        // Prometheus ë¯¸ë“¤ì›¨ì–´ (API ìš”ì²­ë§Œ ì¸¡ì •)
        <span class="cov0" title="0">v1.Use(middleware.PrometheusMiddleware())

        // Swagger ë¬¸ì„œ - /ojeomneo/v1/docs
        v1.Get("/docs/*", swagger.New(swagger.Config{
                URL:          "/ojeomneo/v1/docs/doc.json",
                DeepLinking:  true,
                DocExpansion: "list",
                Title:        "Ojeomneo API Documentation",
        }))

        // í•¸ë“¤ëŸ¬ ì´ˆê¸°í™”
        healthHandler := handler.NewHealthHandler(db)
        menuHandler := handler.NewMenuHandler(menuService)
        sketchHandler := handler.NewSketchHandler(sketchService)

        // Health Check ì—”ë“œí¬ì¸íŠ¸
        // /ojeomneo/v1/healthcheck - ìƒì„¸ ìƒíƒœ (ëª¨ë‹ˆí„°ë§ìš©, í•­ìƒ 200)
        // /ojeomneo/v1/healthcheck/live - Kubernetes startup/liveness probeìš© (í•­ìƒ 200)
        // /ojeomneo/v1/healthcheck/ready - Kubernetes readiness probeìš© (DB ì—°ê²° ì‹œ 200)
        v1.Get("/healthcheck", healthHandler.HealthCheck)
        v1.Get("/healthcheck/live", healthHandler.LivenessCheck)
        v1.Get("/healthcheck/ready", healthHandler.ReadinessCheck)

        // Menu ì—”ë“œí¬ì¸íŠ¸
        v1.Get("/menus", menuHandler.List)
        v1.Get("/menus/categories", menuHandler.GetCategories)
        v1.Get("/menus/:id", menuHandler.GetByID)

        // Sketch ì—”ë“œí¬ì¸íŠ¸
        v1.Post("/sketch/analyze", sketchHandler.Analyze)
        v1.Get("/sketch/history", sketchHandler.GetHistory)
        v1.Get("/sketch/:id", sketchHandler.GetByID)

        // ì„œë²„ ì‹œì‘
        port := os.Getenv("APP_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "3000"
        }</span>

        <span class="cov0" title="0">log.Printf("ğŸš€ Server starting on port %s", port)
        log.Printf("ğŸ“š Swagger: http://localhost:%s/ojeomneo/v1/docs", port)
        log.Printf("ğŸ“Š Metrics: http://localhost:%s/ojeomneo/metrics (internal only)", port)
        log.Printf("ğŸ¨ Sketch API: POST http://localhost:%s/ojeomneo/v1/sketch/analyze", port)

        if err := app.Listen(":" + port); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "termsOfService": "http://swagger.io/terms/",
        "contact": {
            "name": "API Support",
            "email": "support@woohalabs.com"
        },
        "license": {
            "name": "Apache 2.0",
            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/healthcheck": {
            "get": {
                "description": "ì„œë²„ ë° ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ìƒì„¸ í™•ì¸ (ëª¨ë‹ˆí„°ë§/ë””ë²„ê¹…ìš©)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "ì„œë²„ ìƒì„¸ í—¬ìŠ¤ì²´í¬",
                "responses": {
                    "200": {
                        "description": "ìƒíƒœ ì •ë³´ ë°˜í™˜ (DB ì—°ê²° ì‹¤íŒ¨í•´ë„ 200)",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.HealthResponse"
                        }
                    }
                }
            }
        },
        "/healthcheck/live": {
            "get": {
                "description": "ì„œë²„ê°€ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸ (DB ì—°ê²° ë¬´ê´€)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Liveness ì²´í¬ (Kubernetes startup/liveness probeìš©)",
                "responses": {
                    "200": {
                        "description": "ì„œë²„ ì •ìƒ ê°€ë™ ì¤‘",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.LivenessResponse"
                        }
                    }
                }
            }
        },
        "/healthcheck/ready": {
            "get": {
                "description": "ì„œë²„ê°€ íŠ¸ë˜í”½ì„ ë°›ì„ ì¤€ë¹„ê°€ ëëŠ”ì§€ í™•ì¸ (DB ì—°ê²° í¬í•¨)",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Health"
                ],
                "summary": "Readiness ì²´í¬ (Kubernetes readiness probeìš©)",
                "responses": {
                    "200": {
                        "description": "íŠ¸ë˜í”½ ìˆ˜ì‹  ì¤€ë¹„ ì™„ë£Œ",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.ReadinessResponse"
                        }
                    },
                    "503": {
                        "description": "íŠ¸ë˜í”½ ìˆ˜ì‹  ë¶ˆê°€ (DB ì—°ê²° ì‹¤íŒ¨)",
                        "schema": {
                            "$ref": "#/definitions/internal_handler.ReadinessResponse"
                        }
                    }
                }
            }
        },
        "/menus": {
            "get": {
                "description": "ë©”ë‰´ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤. ì¹´í…Œê³ ë¦¬ì™€ íƒœê·¸ë¡œ í•„í„°ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "menu"
                ],
                "summary": "ë©”ë‰´ ëª©ë¡ ì¡°íšŒ",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ì¹´í…Œê³ ë¦¬ í•„í„° (korean, chinese, japanese, western, asian, snack, cafe, other)",
                        "name": "category",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "description": "íƒœê·¸ í•„í„°",
                        "name": "tag",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "í˜ì´ì§€ ë²ˆí˜¸",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 20,
                        "description": "í˜ì´ì§€ë‹¹ ê°œìˆ˜",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/menus/categories": {
            "get": {
                "description": "ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ë‰´ ì¹´í…Œê³ ë¦¬ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "menu"
                ],
                "summary": "ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/menus/{id}": {
            "get": {
                "description": "ë©”ë‰´ IDë¡œ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "menu"
                ],
                "summary": "ë©”ë‰´ ìƒì„¸ ì¡°íšŒ",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "ë©”ë‰´ ID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/sketch/analyze": {
            "post": {
                "description": "ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ê°ì •/ë¶„ìœ„ê¸°ë¥¼ íŒŒì•…í•˜ê³  ì–´ìš¸ë¦¬ëŠ” ë©”ë‰´ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sketch"
                ],
                "summary": "ìŠ¤ì¼€ì¹˜ ë¶„ì„ ë° ë©”ë‰´ ì¶”ì²œ",
                "parameters": [
                    {
                        "type": "file",
                        "description": "ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ (PNG/JPEG, max 5MB)",
                        "name": "image",
                        "in": "formData",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "ì¶”ê°€ í…ìŠ¤íŠ¸ ì…ë ¥",
                        "name": "text",
                        "in": "formData"
                    },
                    {
                        "type": "string",
                        "description": "ë””ë°”ì´ìŠ¤ ì‹ë³„ì",
                        "name": "device_id",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/sketch/history": {
            "get": {
                "description": "ë””ë°”ì´ìŠ¤ë³„ ìŠ¤ì¼€ì¹˜ ë¶„ì„ íˆìŠ¤í† ë¦¬ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sketch"
                ],
                "summary": "ìŠ¤ì¼€ì¹˜ íˆìŠ¤í† ë¦¬ ì¡°íšŒ",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ë””ë°”ì´ìŠ¤ ì‹ë³„ì",
                        "name": "device_id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "default": 1,
                        "description": "í˜ì´ì§€ ë²ˆí˜¸",
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "default": 10,
                        "description": "í˜ì´ì§€ë‹¹ ê°œìˆ˜",
                        "name": "limit",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        },
        "/sketch/{id}": {
            "get": {
                "description": "ìŠ¤ì¼€ì¹˜ IDë¡œ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "sketch"
                ],
                "summary": "ìŠ¤ì¼€ì¹˜ ìƒì„¸ ì¡°íšŒ",
                "parameters": [
                    {
                        "type": "string",
                        "description": "ìŠ¤ì¼€ì¹˜ UUID",
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "type": "object",
                            "additionalProperties": true
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "internal_handler.DatabaseStatus": {
            "description": "ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ",
            "type": "object",
            "properties": {
                "connected": {
                    "type": "boolean",
                    "example": true
                },
                "latency_ms": {
                    "type": "integer",
                    "example": 5
                },
                "message": {
                    "type": "string",
                    "example": "Database connection successful"
                }
            }
        },
        "internal_handler.HealthResponse": {
            "description": "ì„œë²„ í—¬ìŠ¤ì²´í¬ ì‘ë‹µ",
            "type": "object",
            "properties": {
                "database": {
                    "$ref": "#/definitions/internal_handler.DatabaseStatus"
                },
                "service": {
                    "type": "string",
                    "example": "ojeomneo-api"
                },
                "status": {
                    "type": "string",
                    "example": "ok"
                },
                "version": {
                    "type": "string",
                    "example": "1.0.0"
                }
            }
        },
        "internal_handler.LivenessResponse": {
            "description": "Kubernetes liveness/startup probeìš© ê°„ë‹¨í•œ ì‘ë‹µ",
            "type": "object",
            "properties": {
                "service": {
                    "type": "string",
                    "example": "ojeomneo-api"
                },
                "status": {
                    "type": "string",
                    "example": "ok"
                }
            }
        },
        "internal_handler.ReadinessResponse": {
            "description": "Kubernetes readiness probeìš© ì‘ë‹µ",
            "type": "object",
            "properties": {
                "database": {
                    "type": "boolean",
                    "example": true
                },
                "ready": {
                    "type": "boolean",
                    "example": true
                },
                "status": {
                    "type": "string",
                    "example": "ok"
                }
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0.0",
        Host:             "api.woohalabs.com",
        BasePath:         "/ojeomneo/v1",
        Schemes:          []string{"https", "http"},
        Title:            "Ojeomneo API",
        Description:      "Go Fiber v2 ê¸°ë°˜ REST API ì„œë²„ - ìŠ¤ì¼€ì¹˜ ê¸°ë°˜ ë©”ë‰´ ì¶”ì²œ",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "os"
)

// Config ì• í”Œë¦¬ì¼€ì´ì…˜ ì„¤ì •
type Config struct {
        AppEnv  string
        AppPort string

        DBHost     string
        DBPort     string
        DBName     string
        DBUser     string
        DBPassword string

        RedisHost     string
        RedisPort     string
        RedisPassword string

        // Gemini ì„¤ì •
        GeminiAPIKey string
        GeminiModel  string
}

// Load í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì • ë¡œë“œ
// Kubernetes Secret í‚¤ ì´ë¦„ì— ë§ì¶° POSTGRES_*, REDIS_* í˜•ì‹ ì‚¬ìš©
func Load() *Config <span class="cov0" title="0">{
        return &amp;Config{
                AppEnv:  getEnv("APP_ENV", "development"),
                AppPort: getEnv("APP_PORT", "3000"),

                DBHost:     getEnv("POSTGRES_SERVER", "localhost"),
                DBPort:     getEnv("POSTGRES_PORT", "5432"),
                DBName:     getEnv("POSTGRES_DB", "ojeomneo"),
                DBUser:     getEnv("POSTGRES_USER", "ojeomneo"),
                DBPassword: getEnv("POSTGRES_PASSWORD", ""),

                RedisHost:     getEnv("REDIS_HOST", "localhost"),
                RedisPort:     getEnv("REDIS_PORT", "6379"),
                RedisPassword: getEnv("REDIS_PASSWORD", ""),

                GeminiAPIKey: getEnv("GEMINI_API_KEY", ""),
                GeminiModel:  getEnv("GEMINI_MODEL", "gemini-1.5-flash"),
        }
}</span>

// getEnv í™˜ê²½ë³€ìˆ˜ ì¡°íšŒ (ê¸°ë³¸ê°’ ì§€ì›)
func getEnv(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

import (
        "fmt"

        "github.com/ggorockee/ojeomneo/server/internal/model"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

// ConnectDB PostgreSQL ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²°
func ConnectDB(cfg *Config) (*gorm.DB, error) <span class="cov0" title="0">{
        dsn := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable TimeZone=Asia/Seoul",
                cfg.DBHost,
                cfg.DBPort,
                cfg.DBUser,
                cfg.DBPassword,
                cfg.DBName,
        )

        db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{
                Logger: logger.Default.LogMode(logger.Info),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to database: %w", err)
        }</span>

        // ì—°ê²° í’€ ì„¤ì •
        <span class="cov0" title="0">sqlDB, err := db.DB()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
        }</span>

        <span class="cov0" title="0">sqlDB.SetMaxIdleConns(10)
        sqlDB.SetMaxOpenConns(100)

        // AutoMigrate - í…Œì´ë¸” ìë™ ìƒì„±/ì—…ë°ì´íŠ¸
        if err := db.AutoMigrate(&amp;model.User{}); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to auto migrate: %w", err)
        }</span>

        // email + login_method ë³µí•© unique constraint ì¶”ê°€
        // GORMì—ì„œ ë³µí•© unique indexëŠ” ìˆ˜ë™ìœ¼ë¡œ ì¶”ê°€
        <span class="cov0" title="0">if err := db.Exec(`
                CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_email_login_method
                ON users (email, login_method)
        `).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create unique index: %w", err)
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// ConnectRedis Redis í´ë¼ì´ì–¸íŠ¸ ì—°ê²°
func ConnectRedis(cfg *Config) (*redis.Client, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     fmt.Sprintf("%s:%s", cfg.RedisHost, cfg.RedisPort),
                Password: cfg.RedisPassword,
                DB:       0,

                // ì—°ê²° í’€ ì„¤ì •
                PoolSize:     10,
                MinIdleConns: 5,
                PoolTimeout:  30 * time.Second,

                // íƒ€ì„ì•„ì›ƒ ì„¤ì •
                DialTimeout:  5 * time.Second,
                ReadTimeout:  3 * time.Second,
                WriteTimeout: 3 * time.Second,
        })

        // ì—°ê²° í…ŒìŠ¤íŠ¸
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to redis: %w", err)
        }</span>

        <span class="cov0" title="0">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "os"

        "github.com/gofiber/fiber/v2"
)

// ErrorResponse ì—ëŸ¬ ì‘ë‹µ êµ¬ì¡°ì²´ (Naver ìŠ¤íƒ€ì¼)
type ErrorResponse struct {
        Success bool      `json:"success"`
        Error   ErrorInfo `json:"error"`
}

// ErrorInfo ì—ëŸ¬ ìƒì„¸ ì •ë³´
// message: ì‚¬ìš©ììš© (í•œê¸€, ì¹œì ˆí•˜ê²Œ)
// detail: ê°œë°œììš© (ë””ë²„ê¹… ì •ë³´, productionì—ì„œëŠ” ìˆ¨ê¹€)
type ErrorInfo struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Detail  string `json:"detail,omitempty"`
}

// ì—ëŸ¬ ì½”ë“œë³„ ì‚¬ìš©ì ë©”ì‹œì§€ (Naver ìŠ¤íƒ€ì¼)
var userMessages = map[string]string{
        "INVALID_INPUT":      "ì…ë ¥ ì •ë³´ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ ì£¼ì„¸ìš”.",
        "NOT_FOUND":          "ìš”ì²­í•˜ì‹  ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
        "UNAUTHORIZED":       "ë¡œê·¸ì¸ì´ í•„ìš”í•œ ì„œë¹„ìŠ¤ì…ë‹ˆë‹¤.",
        "FORBIDDEN":          "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.",
        "METHOD_NOT_ALLOWED": "ì§€ì›í•˜ì§€ ì•ŠëŠ” ìš”ì²­ ë°©ì‹ì…ë‹ˆë‹¤.",
        "INTERNAL_ERROR":     "ì¼ì‹œì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
        "DB_ERROR":           "ì„œë¹„ìŠ¤ ì—°ê²°ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        "RATE_LIMIT":         "ìš”ì²­ì´ ë„ˆë¬´ ë§ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.",
        "BAD_REQUEST":        "ìš”ì²­ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
        "CONFLICT":           "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì •ë³´ì…ë‹ˆë‹¤.",
        "VALIDATION_ERROR":   "ì…ë ¥ê°’ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.",
}

// getUserMessage ì—ëŸ¬ ì½”ë“œì— í•´ë‹¹í•˜ëŠ” ì‚¬ìš©ì ë©”ì‹œì§€ ë°˜í™˜
func getUserMessage(code string) string <span class="cov0" title="0">{
        if msg, ok := userMessages[code]; ok </span><span class="cov0" title="0">{
                return msg
        }</span>
        <span class="cov0" title="0">return "ì¼ì‹œì ì¸ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”."</span>
}

// isProduction ìš´ì˜ í™˜ê²½ì¸ì§€ í™•ì¸
func isProduction() bool <span class="cov0" title="0">{
        return os.Getenv("APP_ENV") == "production"
}</span>

// CustomErrorHandler Fiber ì»¤ìŠ¤í…€ ì—ëŸ¬ í•¸ë“¤ëŸ¬
func CustomErrorHandler(c *fiber.Ctx, err error) error <span class="cov0" title="0">{
        code := fiber.StatusInternalServerError
        errorCode := "INTERNAL_ERROR"
        detail := err.Error()

        // Fiber ì—ëŸ¬ì¸ ê²½ìš° ìƒíƒœ ì½”ë“œ ì¶”ì¶œ
        if e, ok := err.(*fiber.Error); ok </span><span class="cov0" title="0">{
                code = e.Code
                detail = e.Message

                switch code </span>{
                case fiber.StatusNotFound:<span class="cov0" title="0">
                        errorCode = "NOT_FOUND"</span>
                case fiber.StatusBadRequest:<span class="cov0" title="0">
                        errorCode = "BAD_REQUEST"</span>
                case fiber.StatusUnauthorized:<span class="cov0" title="0">
                        errorCode = "UNAUTHORIZED"</span>
                case fiber.StatusForbidden:<span class="cov0" title="0">
                        errorCode = "FORBIDDEN"</span>
                case fiber.StatusMethodNotAllowed:<span class="cov0" title="0">
                        errorCode = "METHOD_NOT_ALLOWED"</span>
                case fiber.StatusConflict:<span class="cov0" title="0">
                        errorCode = "CONFLICT"</span>
                case fiber.StatusTooManyRequests:<span class="cov0" title="0">
                        errorCode = "RATE_LIMIT"</span>
                }
        }

        <span class="cov0" title="0">response := ErrorResponse{
                Success: false,
                Error: ErrorInfo{
                        Code:    errorCode,
                        Message: getUserMessage(errorCode),
                },
        }

        // ê°œë°œ í™˜ê²½ì—ì„œë§Œ detail í¬í•¨
        if !isProduction() </span><span class="cov0" title="0">{
                response.Error.Detail = detail
        }</span>

        <span class="cov0" title="0">return c.Status(code).JSON(response)</span>
}

// NewError ì—ëŸ¬ ì‘ë‹µ ìƒì„± í—¬í¼
func NewError(c *fiber.Ctx, status int, code, detail string) error <span class="cov0" title="0">{
        response := ErrorResponse{
                Success: false,
                Error: ErrorInfo{
                        Code:    code,
                        Message: getUserMessage(code),
                },
        }

        // ê°œë°œ í™˜ê²½ì—ì„œë§Œ detail í¬í•¨
        if !isProduction() </span><span class="cov0" title="0">{
                response.Error.Detail = detail
        }</span>

        <span class="cov0" title="0">return c.Status(status).JSON(response)</span>
}

// NewValidationError ê²€ì¦ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewValidationError(c *fiber.Ctx, field, reason string) error <span class="cov0" title="0">{
        detail := field + " í•„ë“œê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: " + reason
        return NewError(c, fiber.StatusBadRequest, "VALIDATION_ERROR", detail)
}</span>

// NewNotFoundError ë¦¬ì†ŒìŠ¤ ì—†ìŒ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewNotFoundError(c *fiber.Ctx, resource, id string) error <span class="cov0" title="0">{
        detail := resource + " ID " + id + "ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
        return NewError(c, fiber.StatusNotFound, "NOT_FOUND", detail)
}</span>

// NewUnauthorizedError ì¸ì¦ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewUnauthorizedError(c *fiber.Ctx, reason string) error <span class="cov0" title="0">{
        return NewError(c, fiber.StatusUnauthorized, "UNAUTHORIZED", reason)
}</span>

// NewForbiddenError ê¶Œí•œ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewForbiddenError(c *fiber.Ctx, reason string) error <span class="cov0" title="0">{
        return NewError(c, fiber.StatusForbidden, "FORBIDDEN", reason)
}</span>

// NewInternalError ë‚´ë¶€ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewInternalError(c *fiber.Ctx, detail string) error <span class="cov0" title="0">{
        return NewError(c, fiber.StatusInternalServerError, "INTERNAL_ERROR", detail)
}</span>

// NewDBError ë°ì´í„°ë² ì´ìŠ¤ ì—ëŸ¬ ì‘ë‹µ ìƒì„±
func NewDBError(c *fiber.Ctx, detail string) error <span class="cov0" title="0">{
        return NewError(c, fiber.StatusInternalServerError, "DB_ERROR", "ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ì‹¤íŒ¨: "+detail)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "time"

        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"
)

// HealthHandler í—¬ìŠ¤ì²´í¬ í•¸ë“¤ëŸ¬
type HealthHandler struct {
        db *gorm.DB
}

// NewHealthHandler HealthHandler ìƒì„±ì
func NewHealthHandler(db *gorm.DB) *HealthHandler <span class="cov0" title="0">{
        return &amp;HealthHandler{db: db}
}</span>

// HealthResponse í—¬ìŠ¤ì²´í¬ ì‘ë‹µ êµ¬ì¡°ì²´
// @Description ì„œë²„ í—¬ìŠ¤ì²´í¬ ì‘ë‹µ
type HealthResponse struct {
        Status   string         `json:"status" example:"ok"`
        Service  string         `json:"service" example:"ojeomneo-api"`
        Version  string         `json:"version" example:"1.0.0"`
        Database DatabaseStatus `json:"database"`
}

// LivenessResponse Liveness ì²´í¬ ì‘ë‹µ
// @Description Kubernetes liveness/startup probeìš© ê°„ë‹¨í•œ ì‘ë‹µ
type LivenessResponse struct {
        Status  string `json:"status" example:"ok"`
        Service string `json:"service" example:"ojeomneo-api"`
}

// ReadinessResponse Readiness ì²´í¬ ì‘ë‹µ
// @Description Kubernetes readiness probeìš© ì‘ë‹µ
type ReadinessResponse struct {
        Status   string `json:"status" example:"ok"`
        Ready    bool   `json:"ready" example:"true"`
        Database bool   `json:"database" example:"true"`
}

// DatabaseStatus ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ
// @Description ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìƒíƒœ
type DatabaseStatus struct {
        Connected bool   `json:"connected" example:"true"`
        LatencyMs int64  `json:"latency_ms" example:"5"`
        Message   string `json:"message,omitempty" example:"Database connection successful"`
}

// LivenessCheck godoc
// @Summary Liveness ì²´í¬ (Kubernetes startup/liveness probeìš©)
// @Description ì„œë²„ê°€ ì‚´ì•„ìˆëŠ”ì§€ í™•ì¸ (DB ì—°ê²° ë¬´ê´€)
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} LivenessResponse "ì„œë²„ ì •ìƒ ê°€ë™ ì¤‘"
// @Router /healthcheck/live [get]
func (h *HealthHandler) LivenessCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.JSON(LivenessResponse{
                Status:  "ok",
                Service: "ojeomneo-api",
        })
}</span>

// ReadinessCheck godoc
// @Summary Readiness ì²´í¬ (Kubernetes readiness probeìš©)
// @Description ì„œë²„ê°€ íŠ¸ë˜í”½ì„ ë°›ì„ ì¤€ë¹„ê°€ ëëŠ”ì§€ í™•ì¸ (DB ì—°ê²° í¬í•¨)
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} ReadinessResponse "íŠ¸ë˜í”½ ìˆ˜ì‹  ì¤€ë¹„ ì™„ë£Œ"
// @Failure 503 {object} ReadinessResponse "íŠ¸ë˜í”½ ìˆ˜ì‹  ë¶ˆê°€ (DB ì—°ê²° ì‹¤íŒ¨)"
// @Router /healthcheck/ready [get]
func (h *HealthHandler) ReadinessCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        response := ReadinessResponse{
                Status: "ok",
                Ready:  true,
        }

        // DB ì—°ê²° ì²´í¬
        if h.db == nil </span><span class="cov0" title="0">{
                response.Status = "not_ready"
                response.Ready = false
                response.Database = false
                return c.Status(fiber.StatusServiceUnavailable).JSON(response)
        }</span>

        <span class="cov0" title="0">sqlDB, err := h.db.DB()
        if err != nil </span><span class="cov0" title="0">{
                response.Status = "not_ready"
                response.Ready = false
                response.Database = false
                return c.Status(fiber.StatusServiceUnavailable).JSON(response)
        }</span>

        <span class="cov0" title="0">if err = sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                response.Status = "not_ready"
                response.Ready = false
                response.Database = false
                return c.Status(fiber.StatusServiceUnavailable).JSON(response)
        }</span>

        <span class="cov0" title="0">response.Database = true
        return c.JSON(response)</span>
}

// HealthCheck godoc
// @Summary ì„œë²„ ìƒì„¸ í—¬ìŠ¤ì²´í¬
// @Description ì„œë²„ ë° ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ ìƒì„¸ í™•ì¸ (ëª¨ë‹ˆí„°ë§/ë””ë²„ê¹…ìš©)
// @Tags Health
// @Accept json
// @Produce json
// @Success 200 {object} HealthResponse "ìƒíƒœ ì •ë³´ ë°˜í™˜ (DB ì—°ê²° ì‹¤íŒ¨í•´ë„ 200)"
// @Router /healthcheck [get]
func (h *HealthHandler) HealthCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        response := HealthResponse{
                Service: "ojeomneo-api",
                Version: "1.0.0",
        }

        // DBê°€ nilì¸ ê²½ìš° (ì—°ê²° ì‹¤íŒ¨ ìƒíƒœë¡œ ì‹œì‘ëœ ê²½ìš°)
        if h.db == nil </span><span class="cov0" title="0">{
                response.Status = "degraded"
                response.Database = DatabaseStatus{
                        Connected: false,
                        LatencyMs: 0,
                        Message:   "Database not configured",
                }
                // ëª¨ë‹ˆí„°ë§ìš©ì´ë¯€ë¡œ í•­ìƒ 200 ë°˜í™˜ (ìƒíƒœ ì •ë³´ë§Œ ì œê³µ)
                return c.JSON(response)
        }</span>

        // DB ì—°ê²° ì²´í¬ ë° ë ˆì´í„´ì‹œ ì¸¡ì •
        <span class="cov0" title="0">start := time.Now()
        sqlDB, err := h.db.DB()

        if err != nil </span><span class="cov0" title="0">{
                response.Status = "degraded"
                response.Database = DatabaseStatus{
                        Connected: false,
                        LatencyMs: 0,
                        Message:   "Failed to get database connection",
                }
                return c.JSON(response)
        }</span>

        // Ping í…ŒìŠ¤íŠ¸
        <span class="cov0" title="0">err = sqlDB.Ping()
        latency := time.Since(start).Milliseconds()

        if err != nil </span><span class="cov0" title="0">{
                response.Status = "degraded"
                response.Database = DatabaseStatus{
                        Connected: false,
                        LatencyMs: latency,
                        Message:   "Database ping failed: " + err.Error(),
                }
                return c.JSON(response)
        }</span>

        // ì •ìƒ ì‘ë‹µ
        <span class="cov0" title="0">response.Status = "ok"
        response.Database = DatabaseStatus{
                Connected: true,
                LatencyMs: latency,
                Message:   "Database connection successful",
        }

        return c.JSON(response)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "github.com/gofiber/fiber/v2"

        "github.com/ggorockee/ojeomneo/server/internal/service"
)

// MenuHandler ë©”ë‰´ í•¸ë“¤ëŸ¬
type MenuHandler struct {
        menuService *service.MenuService
}

// NewMenuHandler ìƒˆ ë©”ë‰´ í•¸ë“¤ëŸ¬ ìƒì„±
func NewMenuHandler(menuService *service.MenuService) *MenuHandler <span class="cov8" title="1">{
        return &amp;MenuHandler{
                menuService: menuService,
        }
}</span>

// List godoc
// @Summary ë©”ë‰´ ëª©ë¡ ì¡°íšŒ
// @Description ë©”ë‰´ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤. ì¹´í…Œê³ ë¦¬ì™€ íƒœê·¸ë¡œ í•„í„°ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
// @Tags menu
// @Accept json
// @Produce json
// @Param category query string false "ì¹´í…Œê³ ë¦¬ í•„í„° (korean, chinese, japanese, western, asian, snack, cafe, other)"
// @Param tag query string false "íƒœê·¸ í•„í„°"
// @Param page query int false "í˜ì´ì§€ ë²ˆí˜¸" default(1)
// @Param limit query int false "í˜ì´ì§€ë‹¹ ê°œìˆ˜" default(20)
// @Success 200 {object} map[string]interface{}
// @Router /menus [get]
func (h *MenuHandler) List(c *fiber.Ctx) error <span class="cov8" title="1">{
        category := c.Query("category")
        tag := c.Query("tag")
        page := c.QueryInt("page", 1)
        limit := c.QueryInt("limit", 20)

        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 || limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov8" title="1">menus, total, err := h.menuService.List(c.Context(), category, tag, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "success": false,
                        "error":   err.Error(),
                })
        }</span>

        // ì‘ë‹µ ë³€í™˜
        <span class="cov8" title="1">items := make([]map[string]interface{}, len(menus))
        for i, menu := range menus </span><span class="cov8" title="1">{
                items[i] = map[string]interface{}{
                        "id":             menu.ID,
                        "name":           menu.Name,
                        "category":       menu.Category,
                        "category_label": menu.Category.Label(),
                        "image_url":      menu.ImageURL,
                        "emotion_tags":   menu.EmotionTags,
                        "situation_tags": menu.SituationTags,
                        "attribute_tags": menu.AttributeTags,
                }
        }</span>

        <span class="cov8" title="1">return c.JSON(fiber.Map{
                "success": true,
                "data": fiber.Map{
                        "items": items,
                        "pagination": fiber.Map{
                                "page":       page,
                                "limit":      limit,
                                "total":      total,
                                "total_page": (total + int64(limit) - 1) / int64(limit),
                        },
                },
        })</span>
}

// GetByID godoc
// @Summary ë©”ë‰´ ìƒì„¸ ì¡°íšŒ
// @Description ë©”ë‰´ IDë¡œ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤.
// @Tags menu
// @Accept json
// @Produce json
// @Param id path int true "ë©”ë‰´ ID"
// @Success 200 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /menus/{id} [get]
func (h *MenuHandler) GetByID(c *fiber.Ctx) error <span class="cov8" title="1">{
        id, err := c.ParamsInt("id")
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "invalid menu id",
                })
        }</span>

        <span class="cov8" title="1">menu, err := h.menuService.GetByID(c.Context(), uint(id))
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "success": false,
                        "error":   "menu not found",
                })
        }</span>

        <span class="cov8" title="1">return c.JSON(fiber.Map{
                "success": true,
                "data":    menu.ToResponse(),
        })</span>
}

// GetCategories godoc
// @Summary ì¹´í…Œê³ ë¦¬ ëª©ë¡ ì¡°íšŒ
// @Description ì‚¬ìš© ê°€ëŠ¥í•œ ë©”ë‰´ ì¹´í…Œê³ ë¦¬ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.
// @Tags menu
// @Accept json
// @Produce json
// @Success 200 {object} map[string]interface{}
// @Router /menus/categories [get]
func (h *MenuHandler) GetCategories(c *fiber.Ctx) error <span class="cov8" title="1">{
        categories := h.menuService.GetCategories()

        return c.JSON(fiber.Map{
                "success": true,
                "data":    categories,
        })
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "github.com/gofiber/fiber/v2"
        "github.com/google/uuid"

        "github.com/ggorockee/ojeomneo/server/internal/service"
)

// SketchHandler ìŠ¤ì¼€ì¹˜ í•¸ë“¤ëŸ¬
type SketchHandler struct {
        sketchService *service.SketchService
}

// NewSketchHandler ìƒˆ ìŠ¤ì¼€ì¹˜ í•¸ë“¤ëŸ¬ ìƒì„±
func NewSketchHandler(sketchService *service.SketchService) *SketchHandler <span class="cov8" title="1">{
        return &amp;SketchHandler{
                sketchService: sketchService,
        }
}</span>

// AnalyzeRequest ìŠ¤ì¼€ì¹˜ ë¶„ì„ ìš”ì²­ DTO
type AnalyzeRequest struct {
        Text     string `form:"text"`
        DeviceID string `form:"device_id"`
}

// Analyze godoc
// @Summary ìŠ¤ì¼€ì¹˜ ë¶„ì„ ë° ë©”ë‰´ ì¶”ì²œ
// @Description ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ê°ì •/ë¶„ìœ„ê¸°ë¥¼ íŒŒì•…í•˜ê³  ì–´ìš¸ë¦¬ëŠ” ë©”ë‰´ë¥¼ ì¶”ì²œí•©ë‹ˆë‹¤
// @Tags sketch
// @Accept multipart/form-data
// @Produce json
// @Param image formData file true "ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ (PNG/JPEG, max 5MB)"
// @Param text formData string false "ì¶”ê°€ í…ìŠ¤íŠ¸ ì…ë ¥"
// @Param device_id formData string true "ë””ë°”ì´ìŠ¤ ì‹ë³„ì"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /sketch/analyze [post]
func (h *SketchHandler) Analyze(c *fiber.Ctx) error <span class="cov8" title="1">{
        // ë””ë°”ì´ìŠ¤ ID í™•ì¸
        deviceID := c.FormValue("device_id")
        if deviceID == "" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "device_id is required",
                })
        }</span>

        // ì´ë¯¸ì§€ íŒŒì¼ í™•ì¸
        <span class="cov8" title="1">file, err := c.FormFile("image")
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "image file is required",
                })
        }</span>

        // íŒŒì¼ í¬ê¸° í™•ì¸ (5MB)
        <span class="cov8" title="1">if file.Size &gt; 5*1024*1024 </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "image file too large (max 5MB)",
                })
        }</span>

        // íŒŒì¼ ì—´ê¸°
        <span class="cov8" title="1">f, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "success": false,
                        "error":   "failed to read image file",
                })
        }</span>
        <span class="cov8" title="1">defer f.Close()

        // ì´ë¯¸ì§€ ë°ì´í„° ì½ê¸°
        imageData := make([]byte, file.Size)
        if _, err := f.Read(imageData); err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "success": false,
                        "error":   "failed to read image data",
                })
        }</span>

        // ë¶„ì„ ìš”ì²­
        <span class="cov8" title="1">req := &amp;service.AnalyzeRequest{
                ImageData: imageData,
                InputText: c.FormValue("text"),
                DeviceID:  deviceID,
        }

        result, err := h.sketchService.Analyze(c.Context(), req)
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "success": false,
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov0" title="0">return c.JSON(fiber.Map{
                "success": true,
                "data":    result,
        })</span>
}

// HistoryQuery íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
type HistoryQuery struct {
        Page  int `query:"page"`
        Limit int `query:"limit"`
}

// GetHistory godoc
// @Summary ìŠ¤ì¼€ì¹˜ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
// @Description ë””ë°”ì´ìŠ¤ë³„ ìŠ¤ì¼€ì¹˜ ë¶„ì„ íˆìŠ¤í† ë¦¬ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤
// @Tags sketch
// @Accept json
// @Produce json
// @Param device_id query string true "ë””ë°”ì´ìŠ¤ ì‹ë³„ì"
// @Param page query int false "í˜ì´ì§€ ë²ˆí˜¸" default(1)
// @Param limit query int false "í˜ì´ì§€ë‹¹ ê°œìˆ˜" default(10)
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Router /sketch/history [get]
func (h *SketchHandler) GetHistory(c *fiber.Ctx) error <span class="cov8" title="1">{
        deviceID := c.Query("device_id")
        if deviceID == "" </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "device_id is required",
                })
        }</span>

        <span class="cov8" title="1">page := c.QueryInt("page", 1)
        limit := c.QueryInt("limit", 10)

        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 || limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov8" title="1">sketches, total, err := h.sketchService.GetHistory(c.Context(), deviceID, page, limit)
        if err != nil </span><span class="cov0" title="0">{
                return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
                        "success": false,
                        "error":   err.Error(),
                })
        }</span>

        <span class="cov8" title="1">return c.JSON(fiber.Map{
                "success": true,
                "data": fiber.Map{
                        "items": sketches,
                        "pagination": fiber.Map{
                                "page":       page,
                                "limit":      limit,
                                "total":      total,
                                "total_page": (total + int64(limit) - 1) / int64(limit),
                        },
                },
        })</span>
}

// GetByID godoc
// @Summary ìŠ¤ì¼€ì¹˜ ìƒì„¸ ì¡°íšŒ
// @Description ìŠ¤ì¼€ì¹˜ IDë¡œ ìƒì„¸ ì •ë³´ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤
// @Tags sketch
// @Accept json
// @Produce json
// @Param id path string true "ìŠ¤ì¼€ì¹˜ UUID"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Router /sketch/{id} [get]
func (h *SketchHandler) GetByID(c *fiber.Ctx) error <span class="cov8" title="1">{
        idStr := c.Params("id")
        id, err := uuid.Parse(idStr)
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
                        "success": false,
                        "error":   "invalid sketch id",
                })
        }</span>

        <span class="cov8" title="1">sketch, err := h.sketchService.GetByID(c.Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return c.Status(fiber.StatusNotFound).JSON(fiber.Map{
                        "success": false,
                        "error":   "sketch not found",
                })
        }</span>

        <span class="cov8" title="1">return c.JSON(fiber.Map{
                "success": true,
                "data":    sketch,
        })</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "strings"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/redis/go-redis/v9"
)

var (
        // ìºì‹œ ë©”íŠ¸ë¦­
        cacheHits = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "ojeomneo_cache_hits_total",
                        Help: "Total number of cache hits",
                },
                []string{"path"},
        )

        cacheMisses = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "ojeomneo_cache_misses_total",
                        Help: "Total number of cache misses",
                },
                []string{"path"},
        )

        cacheLatency = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "ojeomneo_cache_operation_duration_seconds",
                        Help:    "Cache operation latency in seconds",
                        Buckets: []float64{.001, .005, .01, .025, .05, .1},
                },
                []string{"operation"}, // get, set
        )
)

// CacheConfig ìºì‹œ ì„¤ì •
type CacheConfig struct {
        // ê¸°ë³¸ TTL (ê¸°ë³¸: 5ë¶„)
        DefaultTTL time.Duration
        // ê²½ë¡œë³„ TTL ì„¤ì •
        PathTTL map[string]time.Duration
        // ìºì‹œ ì œì™¸ ê²½ë¡œ
        SkipPaths []string
        // ìºì‹œ ê°€ëŠ¥í•œ HTTP ë©”ì„œë“œ (ê¸°ë³¸: GETë§Œ)
        Methods []string
        // Redis í´ë¼ì´ì–¸íŠ¸
        RedisClient *redis.Client
        // ìºì‹œ í‚¤ prefix
        KeyPrefix string
}

// CachedResponse ìºì‹œëœ ì‘ë‹µ
type CachedResponse struct {
        StatusCode  int               `json:"statusCode"`
        Body        []byte            `json:"body"`
        ContentType string            `json:"contentType"`
        Headers     map[string]string `json:"headers"`
        CachedAt    int64             `json:"cachedAt"`
}

// DefaultCacheConfig ê¸°ë³¸ ì„¤ì •
func DefaultCacheConfig() CacheConfig <span class="cov0" title="0">{
        return CacheConfig{
                DefaultTTL: 5 * time.Minute,
                PathTTL: map[string]time.Duration{
                        "/ojeomneo/v1/config":   30 * time.Minute, // ì„¤ì •ì€ ì˜¤ë˜ ìºì‹œ
                        "/ojeomneo/v1/menu":     10 * time.Minute, // ë©”ë‰´ ë°ì´í„°
                        "/ojeomneo/v1/category": 15 * time.Minute, // ì¹´í…Œê³ ë¦¬
                },
                SkipPaths: []string{
                        "/ojeomneo/v1/healthcheck",
                        "/ojeomneo/v1/docs",
                        "/ojeomneo/metrics",
                },
                Methods:   []string{"GET"},
                KeyPrefix: "cache:api",
        }
}</span>

// Cache Redis ê¸°ë°˜ API ìºì‹± ë¯¸ë“¤ì›¨ì–´
func Cache(config ...CacheConfig) fiber.Handler <span class="cov0" title="0">{
        cfg := DefaultCacheConfig()
        if len(config) &gt; 0 </span><span class="cov0" title="0">{
                cfg = config[0]
        }</span>

        <span class="cov0" title="0">return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Redis í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ í†µê³¼
                if cfg.RedisClient == nil </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // ìºì‹œ ê°€ëŠ¥í•œ ë©”ì„œë“œì¸ì§€ í™•ì¸
                <span class="cov0" title="0">method := c.Method()
                methodAllowed := false
                for _, m := range cfg.Methods </span><span class="cov0" title="0">{
                        if m == method </span><span class="cov0" title="0">{
                                methodAllowed = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !methodAllowed </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // ì œì™¸ ê²½ë¡œ ì²´í¬
                <span class="cov0" title="0">path := c.Path()
                for _, skipPath := range cfg.SkipPaths </span><span class="cov0" title="0">{
                        if strings.HasPrefix(path, skipPath) </span><span class="cov0" title="0">{
                                return c.Next()
                        }</span>
                }

                // Cache-Control: no-cache í—¤ë” ì²´í¬
                <span class="cov0" title="0">if c.Get("Cache-Control") == "no-cache" </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // ìºì‹œ í‚¤ ìƒì„± (ê²½ë¡œ + ì¿¼ë¦¬ìŠ¤íŠ¸ë§)
                <span class="cov0" title="0">cacheKey := generateCacheKey(cfg.KeyPrefix, path, c.Request().URI().QueryString())

                ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
                defer cancel()

                // ìºì‹œ ì¡°íšŒ
                start := time.Now()
                cached, err := cfg.RedisClient.Get(ctx, cacheKey).Bytes()
                cacheLatency.WithLabelValues("get").Observe(time.Since(start).Seconds())

                if err == nil &amp;&amp; len(cached) &gt; 0 </span><span class="cov0" title="0">{
                        // ìºì‹œ íˆíŠ¸
                        var response CachedResponse
                        if err := json.Unmarshal(cached, &amp;response); err == nil </span><span class="cov0" title="0">{
                                cacheHits.WithLabelValues(path).Inc()

                                // ìºì‹œëœ í—¤ë” ì„¤ì •
                                for key, value := range response.Headers </span><span class="cov0" title="0">{
                                        c.Set(key, value)
                                }</span>
                                <span class="cov0" title="0">c.Set("X-Cache", "HIT")
                                c.Set("X-Cache-Age", fmt.Sprintf("%d", time.Now().Unix()-response.CachedAt))
                                c.Set("Content-Type", response.ContentType)

                                return c.Status(response.StatusCode).Send(response.Body)</span>
                        }
                }

                // ìºì‹œ ë¯¸ìŠ¤ - ë‹¤ìŒ í•¸ë“¤ëŸ¬ ì‹¤í–‰
                <span class="cov0" title="0">cacheMisses.WithLabelValues(path).Inc()

                err = c.Next()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // ì„±ê³µ ì‘ë‹µë§Œ ìºì‹œ (2xx)
                <span class="cov0" title="0">statusCode := c.Response().StatusCode()
                if statusCode &lt; 200 || statusCode &gt;= 300 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // ì‘ë‹µ ìºì‹œ
                <span class="cov0" title="0">ttl := cfg.DefaultTTL
                for pathPrefix, pathTTL := range cfg.PathTTL </span><span class="cov0" title="0">{
                        if strings.HasPrefix(path, pathPrefix) </span><span class="cov0" title="0">{
                                ttl = pathTTL
                                break</span>
                        }
                }

                <span class="cov0" title="0">response := CachedResponse{
                        StatusCode:  statusCode,
                        Body:        c.Response().Body(),
                        ContentType: string(c.Response().Header.ContentType()),
                        Headers:     make(map[string]string),
                        CachedAt:    time.Now().Unix(),
                }

                // ìºì‹œí•  í—¤ë” ë³µì‚¬
                headersToCache := []string{"Content-Encoding", "Vary"}
                for _, h := range headersToCache </span><span class="cov0" title="0">{
                        if v := string(c.Response().Header.Peek(h)); v != "" </span><span class="cov0" title="0">{
                                response.Headers[h] = v
                        }</span>
                }

                // ìºì‹œ ì €ì¥
                <span class="cov0" title="0">if data, err := json.Marshal(response); err == nil </span><span class="cov0" title="0">{
                        start := time.Now()
                        cfg.RedisClient.Set(ctx, cacheKey, data, ttl)
                        cacheLatency.WithLabelValues("set").Observe(time.Since(start).Seconds())
                }</span>

                <span class="cov0" title="0">c.Set("X-Cache", "MISS")

                return nil</span>
        }
}

// generateCacheKey ìºì‹œ í‚¤ ìƒì„±
func generateCacheKey(prefix, path string, query []byte) string <span class="cov0" title="0">{
        hash := sha256.New()
        hash.Write([]byte(path))
        hash.Write(query)
        return fmt.Sprintf("%s:%s", prefix, hex.EncodeToString(hash.Sum(nil))[:16])
}</span>

// CacheInvalidator ìºì‹œ ë¬´íš¨í™” í—¬í¼
type CacheInvalidator struct {
        client    *redis.Client
        keyPrefix string
}

// NewCacheInvalidator ìºì‹œ ë¬´íš¨í™” í—¬í¼ ìƒì„±
func NewCacheInvalidator(client *redis.Client, keyPrefix string) *CacheInvalidator <span class="cov0" title="0">{
        return &amp;CacheInvalidator{
                client:    client,
                keyPrefix: keyPrefix,
        }
}</span>

// InvalidatePattern íŒ¨í„´ ê¸°ë°˜ ìºì‹œ ë¬´íš¨í™”
func (ci *CacheInvalidator) InvalidatePattern(ctx context.Context, pattern string) error <span class="cov0" title="0">{
        if ci.client == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fullPattern := fmt.Sprintf("%s:%s*", ci.keyPrefix, pattern)
        iter := ci.client.Scan(ctx, 0, fullPattern, 100).Iterator()

        var keys []string
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                keys = append(keys, iter.Val())
        }</span>

        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                return ci.client.Del(ctx, keys...).Err()
        }</span>

        <span class="cov0" title="0">return iter.Err()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "net"
        "strconv"
        "strings"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/adaptor"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        // HTTP ìš”ì²­ ìˆ˜
        httpRequestsTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "ojeomneo_http_requests_total",
                        Help: "Total number of HTTP requests",
                },
                []string{"method", "path", "status"},
        )

        // HTTP ìš”ì²­ ì§€ì—°ì‹œê°„ (íˆìŠ¤í† ê·¸ë¨)
        httpRequestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "ojeomneo_http_request_duration_seconds",
                        Help:    "HTTP request latency in seconds",
                        Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
                },
                []string{"method", "path"},
        )

        // í™œì„± ì—°ê²° ìˆ˜
        httpActiveConnections = promauto.NewGauge(
                prometheus.GaugeOpts{
                        Name: "ojeomneo_http_active_connections",
                        Help: "Number of active HTTP connections",
                },
        )

        // ìš”ì²­ í¬ê¸° (Summary)
        httpRequestSize = promauto.NewSummaryVec(
                prometheus.SummaryOpts{
                        Name:       "ojeomneo_http_request_size_bytes",
                        Help:       "HTTP request size in bytes",
                        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
                },
                []string{"method", "path"},
        )

        // ì‘ë‹µ í¬ê¸° (Summary)
        httpResponseSize = promauto.NewSummaryVec(
                prometheus.SummaryOpts{
                        Name:       "ojeomneo_http_response_size_bytes",
                        Help:       "HTTP response size in bytes",
                        Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
                },
                []string{"method", "path"},
        )
)

// PrometheusMiddleware Prometheus ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë¯¸ë“¤ì›¨ì–´
func PrometheusMiddleware() fiber.Handler <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // /docs, /metrics ê²½ë¡œëŠ” ì œì™¸
                path := c.Path()
                if strings.Contains(path, "/docs") || strings.Contains(path, "/metrics") </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                <span class="cov0" title="0">start := time.Now()

                httpActiveConnections.Inc()
                defer httpActiveConnections.Dec()

                // ìš”ì²­ í¬ê¸° ê¸°ë¡
                reqSize := float64(len(c.Body()))

                // ë‹¤ìŒ í•¸ë“¤ëŸ¬ ì‹¤í–‰
                err := c.Next()

                // ë©”íŠ¸ë¦­ ê¸°ë¡
                duration := time.Since(start).Seconds()
                status := strconv.Itoa(c.Response().StatusCode())
                method := c.Method()
                routePath := c.Route().Path
                if routePath == "" </span><span class="cov0" title="0">{
                        routePath = path
                }</span>

                // ì‘ë‹µ í¬ê¸°
                <span class="cov0" title="0">respSize := float64(len(c.Response().Body()))

                httpRequestsTotal.WithLabelValues(method, routePath, status).Inc()
                httpRequestDuration.WithLabelValues(method, routePath).Observe(duration)
                httpRequestSize.WithLabelValues(method, routePath).Observe(reqSize)
                httpResponseSize.WithLabelValues(method, routePath).Observe(respSize)

                return err</span>
        }
}

// PrometheusHandler Prometheus ë©”íŠ¸ë¦­ í•¸ë“¤ëŸ¬
func PrometheusHandler() fiber.Handler <span class="cov0" title="0">{
        return adaptor.HTTPHandler(promhttp.Handler())
}</span>

// InternalOnly ë‚´ë¶€ë§ ì ‘ê·¼ ì œí•œ ë¯¸ë“¤ì›¨ì–´
// ë³´ì•ˆì„ ìœ„í•´ /metrics ê²½ë¡œëŠ” ë‚´ë¶€ë§ì—ì„œë§Œ ì ‘ê·¼ ê°€ëŠ¥
func InternalOnly() fiber.Handler <span class="cov0" title="0">{
        // í—ˆìš©ëœ ë‚´ë¶€ IP ëŒ€ì—­
        allowedCIDRs := []string{
                "127.0.0.0/8",     // localhost
                "10.0.0.0/8",      // Private Class A
                "172.16.0.0/12",   // Private Class B
                "192.168.0.0/16",  // Private Class C
                "::1/128",         // IPv6 localhost
                "fc00::/7",        // IPv6 private
        }

        var allowedNets []*net.IPNet
        for _, cidr := range allowedCIDRs </span><span class="cov0" title="0">{
                _, ipNet, err := net.ParseCIDR(cidr)
                if err == nil </span><span class="cov0" title="0">{
                        allowedNets = append(allowedNets, ipNet)
                }</span>
        }

        <span class="cov0" title="0">return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // X-Forwarded-For í—¤ë” ë˜ëŠ” ì§ì ‘ IP í™•ì¸
                clientIP := c.IP()

                // X-Real-IP í—¤ë” í™•ì¸ (í”„ë¡ì‹œ ë’¤ì— ìˆëŠ” ê²½ìš°)
                if realIP := c.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                        clientIP = realIP
                }</span>

                <span class="cov0" title="0">ip := net.ParseIP(clientIP)
                if ip == nil </span><span class="cov0" title="0">{
                        return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                                "success": false,
                                "error": fiber.Map{
                                        "code":    "FORBIDDEN",
                                        "message": "Invalid IP address",
                                },
                        })
                }</span>

                // ë‚´ë¶€ë§ IP ì²´í¬
                <span class="cov0" title="0">for _, ipNet := range allowedNets </span><span class="cov0" title="0">{
                        if ipNet.Contains(ip) </span><span class="cov0" title="0">{
                                return c.Next()
                        }</span>
                }

                // ê°œë°œ í™˜ê²½ì—ì„œëŠ” ëª¨ë“  ì ‘ê·¼ í—ˆìš© (í™˜ê²½ë³€ìˆ˜ë¡œ ì œì–´)
                // APP_ENVê°€ developmentì¸ ê²½ìš° í—ˆìš©
                // í”„ë¡œë•ì…˜ì—ì„œëŠ” ë‚´ë¶€ë§ë§Œ í—ˆìš©
                <span class="cov0" title="0">return c.Status(fiber.StatusForbidden).JSON(fiber.Map{
                        "success": false,
                        "error": fiber.Map{
                                "code":    "FORBIDDEN",
                                "message": "Access denied. Internal network only.",
                        },
                })</span>
        }
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "github.com/gofiber/fiber/v2"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/redis/go-redis/v9"
)

var (
        // Rate Limit ë©”íŠ¸ë¦­
        rateLimitTotal = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "ojeomneo_ratelimit_requests_total",
                        Help: "Total number of rate limited requests",
                },
                []string{"status"}, // allowed, limited
        )

        rateLimitRemaining = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "ojeomneo_ratelimit_remaining",
                        Help: "Remaining requests in current window",
                },
                []string{"ip"},
        )
)

// RateLimitConfig Rate Limiting ì„¤ì •
type RateLimitConfig struct {
        // ìœˆë„ìš° ì‹œê°„ (ê¸°ë³¸: 1ë¶„)
        Window time.Duration
        // ìœˆë„ìš° ë‚´ ìµœëŒ€ ìš”ì²­ ìˆ˜ (ê¸°ë³¸: 100)
        Max int
        // Rate Limit ì´ˆê³¼ ì‹œ ì‘ë‹µ ë©”ì‹œì§€
        Message string
        // ì œì™¸í•  ê²½ë¡œ (healthcheck ë“±)
        SkipPaths []string
        // Redis í´ë¼ì´ì–¸íŠ¸
        RedisClient *redis.Client
}

// DefaultRateLimitConfig ê¸°ë³¸ ì„¤ì •
func DefaultRateLimitConfig() RateLimitConfig <span class="cov0" title="0">{
        return RateLimitConfig{
                Window:  1 * time.Minute,
                Max:     100,
                Message: "Too many requests. Please try again later.",
                SkipPaths: []string{
                        "/ojeomneo/v1/healthcheck",
                        "/ojeomneo/v1/healthcheck/live",
                        "/ojeomneo/v1/healthcheck/ready",
                        "/ojeomneo/v1/docs",
                        "/ojeomneo/metrics",
                },
        }
}</span>

// RateLimiter Redis ê¸°ë°˜ Rate Limiting ë¯¸ë“¤ì›¨ì–´
// Sliding Window Log ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©
func RateLimiter(config ...RateLimitConfig) fiber.Handler <span class="cov0" title="0">{
        cfg := DefaultRateLimitConfig()
        if len(config) &gt; 0 </span><span class="cov0" title="0">{
                cfg = config[0]
        }</span>

        <span class="cov0" title="0">return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                // Redis í´ë¼ì´ì–¸íŠ¸ê°€ ì—†ìœ¼ë©´ í†µê³¼
                if cfg.RedisClient == nil </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                // ì œì™¸ ê²½ë¡œ ì²´í¬
                <span class="cov0" title="0">path := c.Path()
                for _, skipPath := range cfg.SkipPaths </span><span class="cov0" title="0">{
                        if len(path) &gt;= len(skipPath) &amp;&amp; path[:len(skipPath)] == skipPath </span><span class="cov0" title="0">{
                                return c.Next()
                        }</span>
                }

                // í´ë¼ì´ì–¸íŠ¸ IP ì¶”ì¶œ
                <span class="cov0" title="0">clientIP := c.IP()
                if realIP := c.Get("X-Real-IP"); realIP != "" </span><span class="cov0" title="0">{
                        clientIP = realIP
                }</span>
                <span class="cov0" title="0">if forwardedFor := c.Get("X-Forwarded-For"); forwardedFor != "" </span><span class="cov0" title="0">{
                        clientIP = forwardedFor
                }</span>

                // Rate Limit í‚¤
                <span class="cov0" title="0">key := fmt.Sprintf("ratelimit:api:%s", clientIP)
                now := time.Now()
                windowStart := now.Add(-cfg.Window)

                ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
                defer cancel()

                // Sliding Window Log ì•Œê³ ë¦¬ì¦˜
                // 1. ìœˆë„ìš° ë°–ì˜ ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
                // 2. í˜„ì¬ ìš”ì²­ ì¶”ê°€
                // 3. ìœˆë„ìš° ë‚´ ìš”ì²­ ìˆ˜ í™•ì¸
                pipe := cfg.RedisClient.Pipeline()

                // ìœˆë„ìš° ë°– ìš”ì²­ ì œê±°
                pipe.ZRemRangeByScore(ctx, key, "0", strconv.FormatInt(windowStart.UnixNano(), 10))

                // í˜„ì¬ ìš”ì²­ ì¶”ê°€
                pipe.ZAdd(ctx, key, redis.Z{
                        Score:  float64(now.UnixNano()),
                        Member: fmt.Sprintf("%d", now.UnixNano()),
                })

                // í˜„ì¬ ìœˆë„ìš° ë‚´ ìš”ì²­ ìˆ˜ ì¡°íšŒ
                countCmd := pipe.ZCard(ctx, key)

                // TTL ì„¤ì • (ìœˆë„ìš° ì‹œê°„ + ì—¬ìœ )
                pipe.Expire(ctx, key, cfg.Window+time.Minute)

                // íŒŒì´í”„ë¼ì¸ ì‹¤í–‰
                _, err := pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        // Redis ì˜¤ë¥˜ ì‹œ í†µê³¼ (fail-open)
                        return c.Next()
                }</span>

                <span class="cov0" title="0">count := countCmd.Val()
                remaining := int64(cfg.Max) - count

                // Rate Limit í—¤ë” ì„¤ì •
                c.Set("X-RateLimit-Limit", strconv.Itoa(cfg.Max))
                c.Set("X-RateLimit-Remaining", strconv.FormatInt(max(0, remaining), 10))
                c.Set("X-RateLimit-Reset", strconv.FormatInt(now.Add(cfg.Window).Unix(), 10))

                // ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                rateLimitRemaining.WithLabelValues(clientIP).Set(float64(max(0, remaining)))

                // Rate Limit ì´ˆê³¼ ì²´í¬
                if count &gt; int64(cfg.Max) </span><span class="cov0" title="0">{
                        rateLimitTotal.WithLabelValues("limited").Inc()

                        retryAfter := int(cfg.Window.Seconds())
                        c.Set("Retry-After", strconv.Itoa(retryAfter))

                        return c.Status(fiber.StatusTooManyRequests).JSON(fiber.Map{
                                "success": false,
                                "error": fiber.Map{
                                        "code":       "RATE_LIMIT_EXCEEDED",
                                        "message":    cfg.Message,
                                        "retryAfter": retryAfter,
                                },
                        })
                }</span>

                <span class="cov0" title="0">rateLimitTotal.WithLabelValues("allowed").Inc()
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package model

import (
        "database/sql/driver"
        "encoding/json"
        "errors"
        "time"

        "gorm.io/gorm"
)

// MenuCategory ë©”ë‰´ ì¹´í…Œê³ ë¦¬
type MenuCategory string

const (
        MenuCategoryKorean   MenuCategory = "korean"   // í•œì‹
        MenuCategoryChinese  MenuCategory = "chinese"  // ì¤‘ì‹
        MenuCategoryJapanese MenuCategory = "japanese" // ì¼ì‹
        MenuCategoryWestern  MenuCategory = "western"  // ì–‘ì‹
        MenuCategoryAsian    MenuCategory = "asian"    // ì•„ì‹œì•ˆ
        MenuCategorySnack    MenuCategory = "snack"    // ë¶„ì‹
        MenuCategoryCafe     MenuCategory = "cafe"     // ì¹´í˜/ë””ì €íŠ¸
        MenuCategoryOther    MenuCategory = "other"    // ê¸°íƒ€
)

// StringArray PostgreSQL text[] íƒ€ì…ì„ ìœ„í•œ ì»¤ìŠ¤í…€ íƒ€ì…
type StringArray []string

// Scan implements sql.Scanner
func (a *StringArray) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov0" title="0">{
                *a = nil
                return nil
        }</span>

        <span class="cov8" title="1">switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                return json.Unmarshal(v, a)</span>
        case string:<span class="cov0" title="0">
                return json.Unmarshal([]byte(v), a)</span>
        default:<span class="cov0" title="0">
                return errors.New("invalid type for StringArray")</span>
        }
}

// Value implements driver.Valuer
func (a StringArray) Value() (driver.Value, error) <span class="cov8" title="1">{
        if a == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(a)</span>
}

// Menu ë©”ë‰´ ëª¨ë¸
type Menu struct {
        ID        uint           `gorm:"primaryKey" json:"id"`
        Name      string         `gorm:"size:100;not null;uniqueIndex" json:"name"`
        Category  MenuCategory   `gorm:"size:50;not null;index" json:"category"`
        ImageURL  string         `gorm:"type:text" json:"image_url,omitempty"`
        CreatedAt time.Time      `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
        DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`

        // íƒœê·¸ (JSONBë¡œ ì €ì¥)
        EmotionTags   StringArray `gorm:"type:jsonb;default:'[]'" json:"emotion_tags"`
        SituationTags StringArray `gorm:"type:jsonb;default:'[]'" json:"situation_tags"`
        AttributeTags StringArray `gorm:"type:jsonb;default:'[]'" json:"attribute_tags"`

        IsActive bool `gorm:"default:true;not null" json:"is_active"`

        // ê´€ê³„
        Recommendations []Recommendation `gorm:"foreignKey:MenuID" json:"recommendations,omitempty"`
}

// TableName GORM í…Œì´ë¸”ëª… ì§€ì •
func (Menu) TableName() string <span class="cov8" title="1">{
        return "menus"
}</span>

// GetAllTags ëª¨ë“  íƒœê·¸ë¥¼ í•˜ë‚˜ì˜ ìŠ¬ë¼ì´ìŠ¤ë¡œ ë°˜í™˜
func (m *Menu) GetAllTags() []string <span class="cov0" title="0">{
        tags := make([]string, 0, len(m.EmotionTags)+len(m.SituationTags)+len(m.AttributeTags))
        tags = append(tags, m.EmotionTags...)
        tags = append(tags, m.SituationTags...)
        tags = append(tags, m.AttributeTags...)
        return tags
}</span>

// MenuResponse API ì‘ë‹µìš© êµ¬ì¡°ì²´
type MenuResponse struct {
        ID            uint         `json:"id"`
        Name          string       `json:"name"`
        Category      MenuCategory `json:"category"`
        CategoryLabel string       `json:"category_label"`
        ImageURL      string       `json:"image_url,omitempty"`
        EmotionTags   []string     `json:"emotion_tags"`
        SituationTags []string     `json:"situation_tags"`
        AttributeTags []string     `json:"attribute_tags"`
}

// ToResponse Menuë¥¼ API ì‘ë‹µìš© êµ¬ì¡°ì²´ë¡œ ë³€í™˜
func (m *Menu) ToResponse() MenuResponse <span class="cov8" title="1">{
        return MenuResponse{
                ID:            m.ID,
                Name:          m.Name,
                Category:      m.Category,
                CategoryLabel: m.Category.Label(),
                ImageURL:      m.ImageURL,
                EmotionTags:   m.EmotionTags,
                SituationTags: m.SituationTags,
                AttributeTags: m.AttributeTags,
        }
}</span>

// Label ì¹´í…Œê³ ë¦¬ í•œê¸€ ë¼ë²¨ ë°˜í™˜
func (c MenuCategory) Label() string <span class="cov8" title="1">{
        labels := map[MenuCategory]string{
                MenuCategoryKorean:   "í•œì‹",
                MenuCategoryChinese:  "ì¤‘ì‹",
                MenuCategoryJapanese: "ì¼ì‹",
                MenuCategoryWestern:  "ì–‘ì‹",
                MenuCategoryAsian:    "ì•„ì‹œì•ˆ",
                MenuCategorySnack:    "ë¶„ì‹",
                MenuCategoryCafe:     "ì¹´í˜/ë””ì €íŠ¸",
                MenuCategoryOther:    "ê¸°íƒ€",
        }
        if label, ok := labels[c]; ok </span><span class="cov8" title="1">{
                return label
        }</span>
        <span class="cov0" title="0">return string(c)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package model

import (
        "time"

        "github.com/google/uuid"
)

// Recommendation ì¶”ì²œ ëª¨ë¸
type Recommendation struct {
        ID        uint      `gorm:"primaryKey" json:"id"`
        SketchID  uuid.UUID `gorm:"type:uuid;not null;index" json:"sketch_id"`
        MenuID    uint      `gorm:"not null;index" json:"menu_id"`
        Reason    string    `gorm:"type:text;not null" json:"reason"`
        Rank      int       `gorm:"not null;default:1" json:"rank"`
        CreatedAt time.Time `gorm:"autoCreateTime" json:"created_at"`

        // ê´€ê³„
        Sketch *Sketch `gorm:"foreignKey:SketchID" json:"sketch,omitempty"`
        Menu   *Menu   `gorm:"foreignKey:MenuID" json:"menu,omitempty"`
}

// TableName GORM í…Œì´ë¸”ëª… ì§€ì •
func (Recommendation) TableName() string <span class="cov8" title="1">{
        return "recommendations"
}</span>

// RecommendationResponse API ì‘ë‹µìš© êµ¬ì¡°ì²´
type RecommendationResponse struct {
        ID       uint   `json:"id"`
        MenuID   uint   `json:"menu_id"`
        MenuName string `json:"menu_name"`
        Reason   string `json:"reason"`
        Rank     int    `json:"rank"`
}

// ToResponse Recommendationì„ API ì‘ë‹µìš© êµ¬ì¡°ì²´ë¡œ ë³€í™˜
func (r *Recommendation) ToResponse() RecommendationResponse <span class="cov0" title="0">{
        resp := RecommendationResponse{
                ID:     r.ID,
                MenuID: r.MenuID,
                Reason: r.Reason,
                Rank:   r.Rank,
        }
        if r.Menu != nil </span><span class="cov0" title="0">{
                resp.MenuName = r.Menu.Name
        }</span>
        <span class="cov0" title="0">return resp</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"
)

// AnalysisMood ë¶„ì„ëœ ë¶„ìœ„ê¸°
type AnalysisMood string

const (
        MoodBright AnalysisMood = "bright" // ë°ìŒ
        MoodCalm   AnalysisMood = "calm"   // ì°¨ë¶„í•¨
        MoodDark   AnalysisMood = "dark"   // ì–´ë‘ì›€
)

// Sketch ìŠ¤ì¼€ì¹˜ ëª¨ë¸
type Sketch struct {
        ID        uuid.UUID      `gorm:"type:uuid;primaryKey;default:gen_random_uuid()" json:"id"`
        DeviceID  string         `gorm:"size:255;not null;index" json:"device_id"`
        UserID    *uint          `gorm:"index" json:"user_id,omitempty"`
        ImagePath string         `gorm:"type:text;not null" json:"image_path"`
        InputText string         `gorm:"type:text" json:"input_text,omitempty"`
        CreatedAt time.Time      `gorm:"autoCreateTime" json:"created_at"`
        DeletedAt gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`

        // LLM ë¶„ì„ ê²°ê³¼ (JSONB)
        AnalysisResult datatypes.JSON `gorm:"type:jsonb" json:"analysis_result,omitempty"`

        // ê´€ê³„
        User            *User            `gorm:"foreignKey:UserID" json:"user,omitempty"`
        Recommendations []Recommendation `gorm:"foreignKey:SketchID" json:"recommendations,omitempty"`
}

// TableName GORM í…Œì´ë¸”ëª… ì§€ì •
func (Sketch) TableName() string <span class="cov8" title="1">{
        return "sketches"
}</span>

// BeforeCreate UUID ìë™ ìƒì„±
func (s *Sketch) BeforeCreate(tx *gorm.DB) error <span class="cov8" title="1">{
        if s.ID == uuid.Nil </span><span class="cov8" title="1">{
                s.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AnalysisResultData ë¶„ì„ ê²°ê³¼ êµ¬ì¡°ì²´
type AnalysisResultData struct {
        Emotion  string       `json:"emotion"`
        Keywords []string     `json:"keywords"`
        Mood     AnalysisMood `json:"mood"`
}

// GetAnalysisResult JSONì„ êµ¬ì¡°ì²´ë¡œ íŒŒì‹±
func (s *Sketch) GetAnalysisResult() (*AnalysisResultData, error) <span class="cov0" title="0">{
        if s.AnalysisResult == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">var result AnalysisResultData
        if err := s.AnalysisResult.UnmarshalJSON([]byte(s.AnalysisResult)); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;result, nil</span>
}

// SketchResponse API ì‘ë‹µìš© êµ¬ì¡°ì²´
type SketchResponse struct {
        ID             uuid.UUID           `json:"sketch_id"`
        Analysis       *AnalysisResultData `json:"analysis,omitempty"`
        Recommendation *RecommendationSet  `json:"recommendation,omitempty"`
        CreatedAt      time.Time           `json:"created_at"`
}

// RecommendationSet ì¶”ì²œ ê²°ê³¼ ì„¸íŠ¸
type RecommendationSet struct {
        Primary      *MenuRecommendation  `json:"primary"`
        Alternatives []MenuRecommendation `json:"alternatives,omitempty"`
}

// MenuRecommendation ê°œë³„ ë©”ë‰´ ì¶”ì²œ
type MenuRecommendation struct {
        MenuID   uint         `json:"menu_id"`
        Name     string       `json:"name"`
        Category MenuCategory `json:"category"`
        ImageURL string       `json:"image_url,omitempty"`
        Reason   string       `json:"reason"`
        Tags     []string     `json:"tags,omitempty"`
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import (
        "time"

        "gorm.io/gorm"
)

// LoginMethod ë¡œê·¸ì¸ ë°©ì‹
type LoginMethod string

const (
        LoginMethodEmail  LoginMethod = "email"
        LoginMethodKakao  LoginMethod = "kakao"
        LoginMethodGoogle LoginMethod = "google"
        LoginMethodApple  LoginMethod = "apple"
)

// User ì‚¬ìš©ì ëª¨ë¸
// Django AbstractUserì™€ í˜¸í™˜ë˜ëŠ” í•„ë“œ êµ¬ì¡°
type User struct {
        ID          uint           `gorm:"primaryKey" json:"id"`
        Password    string         `gorm:"size:128;not null" json:"-"`
        LastLogin   *time.Time     `gorm:"" json:"last_login,omitempty"`
        IsSuperuser bool           `gorm:"default:false;not null" json:"is_superuser"`
        Username    string         `gorm:"size:150;uniqueIndex;not null" json:"username"`
        FirstName   string         `gorm:"size:150;not null;default:''" json:"first_name"`
        LastName    string         `gorm:"size:150;not null;default:''" json:"last_name"`
        Email       string         `gorm:"size:254;not null;index:idx_email_login_method" json:"email"`
        IsStaff     bool           `gorm:"default:false;not null" json:"is_staff"`
        IsActive    bool           `gorm:"default:true;not null" json:"is_active"`
        DateJoined  time.Time      `gorm:"autoCreateTime;not null" json:"date_joined"`
        CreatedAt   time.Time      `gorm:"autoCreateTime" json:"created_at"`
        UpdatedAt   time.Time      `gorm:"autoUpdateTime" json:"updated_at"`
        DeletedAt   gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`

        // SNS ë¡œê·¸ì¸ ì§€ì› í•„ë“œ
        LoginMethod LoginMethod `gorm:"size:20;not null;default:'email';index:idx_email_login_method" json:"login_method"`
        SocialID    string      `gorm:"size:255;not null;default:''" json:"social_id,omitempty"`
}

// TableName GORM í…Œì´ë¸”ëª… ì§€ì •
func (User) TableName() string <span class="cov8" title="1">{
        return "users"
}</span>

// BeforeCreate ìƒì„± ì „ í›…
func (u *User) BeforeCreate(tx *gorm.DB) error <span class="cov0" title="0">{
        if u.LoginMethod == "" </span><span class="cov0" title="0">{
                u.LoginMethod = LoginMethodEmail
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsSocialUser SNS ë¡œê·¸ì¸ ì‚¬ìš©ì ì—¬ë¶€
func (u *User) IsSocialUser() bool <span class="cov0" title="0">{
        return u.LoginMethod != LoginMethodEmail
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package seed

import (
        "log"

        "github.com/ggorockee/ojeomneo/server/internal/model"
        "gorm.io/gorm"
)

// MenuSeed ë©”ë‰´ ì‹œë“œ ë°ì´í„°
var MenuSeed = []model.Menu{
        // ========== í•œì‹ (Korean) ==========
        {
                Name:          "ëœì¥ì°Œê°œ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í‰ì˜¨"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì§‘ë°¥"},
                AttributeTags: model.StringArray{"ë”°ëœ»í•œ", "êµ­ë¬¼", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ê¹€ì¹˜ì°Œê°œ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "íšŒì‹"},
                AttributeTags: model.StringArray{"ë”°ëœ»í•œ", "ë§¤ìš´", "êµ­ë¬¼"},
        },
        {
                Name:          "ì‚¼ê²¹ì‚´",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "í™œë ¥", "í–‰ë³µ"},
                SituationTags: model.StringArray{"íšŒì‹", "ë°ì´íŠ¸"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë“ ë“ í•œ", "êµ¬ì´"},
        },
        {
                Name:          "ë¶ˆê³ ê¸°",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ë³´ìƒ"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "ê°€ì¡±"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë‹¬ì½¤í•œ", "êµ¬ì´"},
        },
        {
                Name:          "ë¹„ë¹”ë°¥",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ê±´ê°•", "í™œë ¥"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë°¥", "ì•¼ì±„", "ê±´ê°•í•œ"},
        },
        {
                Name:          "ì¹¼êµ­ìˆ˜",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í‰ì˜¨"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë”°ëœ»í•œ", "ë©´ë¥˜", "êµ­ë¬¼"},
        },
        {
                Name:          "ìˆœë‘ë¶€ì°Œê°œ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í™œë ¥"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "í•´ì¥"},
                AttributeTags: model.StringArray{"ë”°ëœ»í•œ", "ë§¤ìš´", "êµ­ë¬¼"},
        },
        {
                Name:          "ì œìœ¡ë³¶ìŒ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë§¤ìš´", "ê³ ê¸°", "ë°¥"},
        },
        {
                Name:          "ë‹­ë³¶ìŒíƒ•",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"í™œë ¥", "ë³´ìƒ"},
                SituationTags: model.StringArray{"íšŒì‹", "ê°€ì¡±"},
                AttributeTags: model.StringArray{"ë§¤ìš´", "ê³ ê¸°", "êµ­ë¬¼"},
        },
        {
                Name:          "ê°ˆë¹„ì°œ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "íŠ¹ë³„í•œ"},
                SituationTags: model.StringArray{"ê°€ì¡±", "ëª…ì ˆ"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë‹¬ì½¤í•œ", "íŠ¹ë³„í•œ"},
        },
        {
                Name:          "í•´ì¥êµ­",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "íšŒë³µ"},
                SituationTags: model.StringArray{"í•´ì¥", "í˜¼ë°¥"},
                AttributeTags: model.StringArray{"ë”°ëœ»í•œ", "êµ­ë¬¼", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ìœ¡íšŒ",
                Category:      model.MenuCategoryKorean,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "íŠ¹ë³„í•œ"},
                SituationTags: model.StringArray{"íšŒì‹", "ë°ì´íŠ¸"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ì‹ ì„ í•œ", "íŠ¹ë³„í•œ"},
        },

        // ========== ì¤‘ì‹ (Chinese) ==========
        {
                Name:          "ì§œì¥ë©´",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ë°°ë‹¬"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ë‹¬ì½¤í•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ì§¬ë½•",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ë°°ë‹¬"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ë§¤ìš´", "êµ­ë¬¼"},
        },
        {
                Name:          "íƒ•ìˆ˜ìœ¡",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ë³´ìƒ"},
                SituationTags: model.StringArray{"íšŒì‹", "ê°€ì¡±"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë‹¬ì½¤í•œ", "ë°”ì‚­í•œ"},
        },
        {
                Name:          "ë§ˆíŒŒë‘ë¶€",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë§¤ìš´", "ë‘ë¶€", "ë°¥"},
        },
        {
                Name:          "ê¹í’ê¸°",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"í™œë ¥", "ë³´ìƒ"},
                SituationTags: model.StringArray{"íšŒì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë§¤ìš´", "ë°”ì‚­í•œ"},
        },
        {
                Name:          "ë³¶ìŒë°¥",
                Category:      model.MenuCategoryChinese,
                EmotionTags:   model.StringArray{"í¸ì•ˆ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ë°¥", "ë“ ë“ í•œ", "ê°„í¸í•œ"},
        },

        // ========== ì¼ì‹ (Japanese) ==========
        {
                Name:          "ì´ˆë°¥",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "íŠ¹ë³„í•œ", "í–‰ë³µ"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "íŠ¹ë³„í•œë‚ "},
                AttributeTags: model.StringArray{"í•´ì‚°ë¬¼", "ì‹ ì„ í•œ", "ê³ ê¸‰"},
        },
        {
                Name:          "ë¼ë©˜",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í™œë ¥"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "êµ­ë¬¼", "ë”°ëœ»í•œ"},
        },
        {
                Name:          "ëˆì¹´ì¸ ",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "í–‰ë³µ"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë°”ì‚­í•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ìš°ë™",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í‰ì˜¨"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ê°„ì‹"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "êµ­ë¬¼", "ë”°ëœ»í•œ"},
        },
        {
                Name:          "ê·œë™",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"í¸ì•ˆ", "ë“ ë“ "},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë°¥", "ê°„í¸í•œ"},
        },
        {
                Name:          "ì‚¬ì‹œë¯¸",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "íŠ¹ë³„í•œ"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "íšŒì‹"},
                AttributeTags: model.StringArray{"í•´ì‚°ë¬¼", "ì‹ ì„ í•œ", "ê³ ê¸‰"},
        },
        {
                Name:          "ì˜¤ì½”ë…¸ë¯¸ì•¼ë¼",
                Category:      model.MenuCategoryJapanese,
                EmotionTags:   model.StringArray{"ì¬ë¯¸", "í–‰ë³µ"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "ì¹œêµ¬"},
                AttributeTags: model.StringArray{"ì•¼ì±„", "ë‹¬ì½¤í•œ", "ë…íŠ¹í•œ"},
        },

        // ========== ì–‘ì‹ (Western) ==========
        {
                Name:          "ìŠ¤í…Œì´í¬",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "íŠ¹ë³„í•œ", "ì„±ì·¨"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "íŠ¹ë³„í•œë‚ "},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ê³ ê¸‰", "ë“ ë“ í•œ"},
        },
        {
                Name:          "íŒŒìŠ¤íƒ€",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ë¡œë§¨í‹±"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "í¬ë¦¼", "í† ë§ˆí† "},
        },
        {
                Name:          "í”¼ì",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "í¸ì•ˆ"},
                SituationTags: model.StringArray{"ë°°ë‹¬", "íŒŒí‹°"},
                AttributeTags: model.StringArray{"ì¹˜ì¦ˆ", "ë“ ë“ í•œ", "ë‚˜ëˆ”"},
        },
        {
                Name:          "í–„ë²„ê±°",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"í¸ì•ˆ", "ë§Œì¡±"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ê°„ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë¹µ", "ê°„í¸í•œ"},
        },
        {
                Name:          "ë¦¬ì¡°ë˜",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "ë¡œë§¨í‹±"},
                SituationTags: model.StringArray{"ë°ì´íŠ¸", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë°¥", "í¬ë¦¼", "ë¶€ë“œëŸ¬ìš´"},
        },
        {
                Name:          "ìƒëŸ¬ë“œ",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"ê±´ê°•", "ê°€ë²¼ì›€"},
                SituationTags: model.StringArray{"ë‹¤ì´ì–´íŠ¸", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ì•¼ì±„", "ê°€ë²¼ìš´", "ê±´ê°•í•œ"},
        },
        {
                Name:          "ìˆ˜í”„",
                Category:      model.MenuCategoryWestern,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "ë”°ëœ»í•¨"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì•„ì¹¨"},
                AttributeTags: model.StringArray{"êµ­ë¬¼", "ë”°ëœ»í•œ", "ê°€ë²¼ìš´"},
        },

        // ========== ì•„ì‹œì•ˆ (Asian) ==========
        {
                Name:          "ìŒ€êµ­ìˆ˜",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"ì²­ëŸ‰", "ì´êµ­ì "},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "êµ­ë¬¼", "ê°€ë²¼ìš´"},
        },
        {
                Name:          "íŒŸíƒ€ì´",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"í™œë ¥", "ì´êµ­ì "},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ë°ì´íŠ¸"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ë‹¬ì½¤í•œ", "ìƒˆì½¤í•œ"},
        },
        {
                Name:          "ë˜ ì–‘ê¿",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"íšŒì‹", "ì ì‹¬"},
                AttributeTags: model.StringArray{"êµ­ë¬¼", "ë§¤ìš´", "ìƒˆì½¤í•œ"},
        },
        {
                Name:          "ì¹´ë ˆ",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"í˜¼ë°¥", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë°¥", "ë§¤ìš´", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ë¶„ì§œ",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"ì²­ëŸ‰", "ê±´ê°•"},
                SituationTags: model.StringArray{"ì ì‹¬", "ë°ì´íŠ¸"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ê³ ê¸°", "ì‹ ì„ í•œ"},
        },
        {
                Name:          "ë°˜ë¯¸",
                Category:      model.MenuCategoryAsian,
                EmotionTags:   model.StringArray{"í™œë ¥", "ì´êµ­ì "},
                SituationTags: model.StringArray{"ê°„ì‹", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë¹µ", "ê³ ê¸°", "ì‹ ì„ í•œ"},
        },

        // ========== ë¶„ì‹ (Snack) ==========
        {
                Name:          "ë–¡ë³¶ì´",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ë§¤ìš´", "ë–¡", "ë‹¬ì½¤í•œ"},
        },
        {
                Name:          "ê¹€ë°¥",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"í¸ì•ˆ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì†Œí’"},
                AttributeTags: model.StringArray{"ë°¥", "ê°„í¸í•œ", "ê°€ë²¼ìš´"},
        },
        {
                Name:          "ë¼ë©´",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í–¥ìˆ˜"},
                SituationTags: model.StringArray{"ì•¼ì‹", "í˜¼ë°¥"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ë§¤ìš´", "êµ­ë¬¼"},
        },
        {
                Name:          "ìˆœëŒ€",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"í–¥ìˆ˜", "í¸ì•ˆ"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë…íŠ¹í•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "íŠ€ê¹€",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "í¸ì•ˆ"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ë°”ì‚­í•œ", "ê°„í¸í•œ", "ë‹¤ì–‘í•œ"},
        },
        {
                Name:          "ëƒ‰ë©´",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"ì²­ëŸ‰", "ì‹œì›í•¨"},
                SituationTags: model.StringArray{"ì—¬ë¦„", "ì ì‹¬"},
                AttributeTags: model.StringArray{"ë©´ë¥˜", "ì‹œì›í•œ", "ìƒˆì½¤í•œ"},
        },
        {
                Name:          "ë§Œë‘",
                Category:      model.MenuCategorySnack,
                EmotionTags:   model.StringArray{"ìœ„ë¡œ", "í¸ì•ˆ"},
                SituationTags: model.StringArray{"ê°„ì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë”°ëœ»í•œ", "ê°„í¸í•œ"},
        },

        // ========== ì¹´í˜/ë””ì €íŠ¸ (Cafe) ==========
        {
                Name:          "ì¼€ì´í¬",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "í–‰ë³µ", "íŠ¹ë³„í•œ"},
                SituationTags: model.StringArray{"ë””ì €íŠ¸", "ìƒì¼"},
                AttributeTags: model.StringArray{"ë‹¬ì½¤í•œ", "ë¶€ë“œëŸ¬ìš´", "íŠ¹ë³„í•œ"},
        },
        {
                Name:          "ì•„ì´ìŠ¤í¬ë¦¼",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ì²­ëŸ‰"},
                SituationTags: model.StringArray{"ë””ì €íŠ¸", "ì—¬ë¦„"},
                AttributeTags: model.StringArray{"ë‹¬ì½¤í•œ", "ì‹œì›í•œ", "ë¶€ë“œëŸ¬ìš´"},
        },
        {
                Name:          "ì»¤í”¼",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"ê°ì„±", "íœ´ì‹"},
                SituationTags: model.StringArray{"ì•„ì¹¨", "íœ´ì‹"},
                AttributeTags: model.StringArray{"ì¹´í˜ì¸", "í–¥ê¸‹í•œ", "ì“´"},
        },
        {
                Name:          "ë¹™ìˆ˜",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"ì²­ëŸ‰", "í–‰ë³µ"},
                SituationTags: model.StringArray{"ì—¬ë¦„", "ë””ì €íŠ¸"},
                AttributeTags: model.StringArray{"ì‹œì›í•œ", "ë‹¬ì½¤í•œ", "ì–¼ìŒ"},
        },
        {
                Name:          "ë§ˆì¹´ë¡±",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "ê·€ì—¬ì›€"},
                SituationTags: model.StringArray{"ë””ì €íŠ¸", "ì„ ë¬¼"},
                AttributeTags: model.StringArray{"ë‹¬ì½¤í•œ", "ë°”ì‚­í•œ", "ì˜ˆìœ"},
        },
        {
                Name:          "ì™€í”Œ",
                Category:      model.MenuCategoryCafe,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ë‹¬ì½¤"},
                SituationTags: model.StringArray{"ë¸ŒëŸ°ì¹˜", "ë””ì €íŠ¸"},
                AttributeTags: model.StringArray{"ë‹¬ì½¤í•œ", "ë°”ì‚­í•œ", "ë¶€ë“œëŸ¬ìš´"},
        },

        // ========== ê¸°íƒ€ (Other) ==========
        {
                Name:          "ì¹˜í‚¨",
                Category:      model.MenuCategoryOther,
                EmotionTags:   model.StringArray{"í–‰ë³µ", "ë³´ìƒ", "í™œë ¥"},
                SituationTags: model.StringArray{"ì•¼ì‹", "ë°°ë‹¬", "íŒŒí‹°"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë°”ì‚­í•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ì¡±ë°œ",
                Category:      model.MenuCategoryOther,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "í™œë ¥"},
                SituationTags: model.StringArray{"ì•¼ì‹", "íšŒì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ì«„ê¹ƒí•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ë³´ìŒˆ",
                Category:      model.MenuCategoryOther,
                EmotionTags:   model.StringArray{"ë³´ìƒ", "ê±´ê°•"},
                SituationTags: model.StringArray{"íšŒì‹", "ê°€ì¡±"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ê±´ê°•í•œ", "ë“ ë“ í•œ"},
        },
        {
                Name:          "ê³±ì°½",
                Category:      model.MenuCategoryOther,
                EmotionTags:   model.StringArray{"í™œë ¥", "ìŠ¤íŠ¸ë ˆìŠ¤í•´ì†Œ"},
                SituationTags: model.StringArray{"íšŒì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "ë§¤ìš´", "êµ¬ì´"},
        },
        {
                Name:          "ì–‘ê¼¬ì¹˜",
                Category:      model.MenuCategoryOther,
                EmotionTags:   model.StringArray{"ì´êµ­ì ", "í™œë ¥"},
                SituationTags: model.StringArray{"íšŒì‹", "ì•¼ì‹"},
                AttributeTags: model.StringArray{"ê³ ê¸°", "í–¥ì‹ ë£Œ", "êµ¬ì´"},
        },
}

// SeedMenus ë©”ë‰´ ì‹œë“œ ë°ì´í„° ì‚½ì…
func SeedMenus(db *gorm.DB) error <span class="cov0" title="0">{
        for _, menu := range MenuSeed </span><span class="cov0" title="0">{
                // ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                var existing model.Menu
                result := db.Where("name = ?", menu.Name).First(&amp;existing)

                if result.Error == gorm.ErrRecordNotFound </span><span class="cov0" title="0">{
                        // ìƒˆë¡œ ìƒì„±
                        menu.IsActive = true
                        if err := db.Create(&amp;menu).Error; err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to seed menu %s: %v", menu.Name, err)
                                return err
                        }</span>
                        <span class="cov0" title="0">log.Printf("Seeded menu: %s", menu.Name)</span>
                }
        }

        <span class="cov0" title="0">log.Printf("Menu seeding completed. Total: %d menus", len(MenuSeed))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "time"
)

// Client Gemini API í´ë¼ì´ì–¸íŠ¸
type Client struct {
        apiKey     string
        model      string
        httpClient *http.Client
        baseURL    string
}

// NewClient ìƒˆ Gemini í´ë¼ì´ì–¸íŠ¸ ìƒì„±
func NewClient(apiKey, model string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                apiKey: apiKey,
                model:  model,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                baseURL: "https://generativelanguage.googleapis.com/v1beta",
        }
}</span>

// AnalysisResult ìŠ¤ì¼€ì¹˜ ë¶„ì„ ê²°ê³¼
type AnalysisResult struct {
        Emotion  string   `json:"emotion"`
        Keywords []string `json:"keywords"`
        Mood     string   `json:"mood"`
}

// AnalyzeSketch ìŠ¤ì¼€ì¹˜ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•˜ì—¬ ê°ì •/í‚¤ì›Œë“œ/ë¶„ìœ„ê¸° ì¶”ì¶œ
func (c *Client) AnalyzeSketch(ctx context.Context, imageData []byte, inputText string) (*AnalysisResult, error) <span class="cov8" title="1">{
        if c.apiKey == "" </span><span class="cov8" title="1">{
                return c.mockAnalysis(inputText), nil
        }</span>

        <span class="cov0" title="0">base64Image := base64.StdEncoding.EncodeToString(imageData)

        systemPrompt := `ë‹¹ì‹ ì€ ê°ì„±ì ì¸ ìŒì‹ ì¶”ì²œê°€ì…ë‹ˆë‹¤. ì‚¬ìš©ìê°€ ê·¸ë¦° ê·¸ë¦¼ì´ë‚˜ ë‚™ì„œë¥¼ ë³´ê³ 
ê·¸ ìˆœê°„ì˜ ê¸°ë¶„, ê°ì •, ë¶„ìœ„ê¸°ë¥¼ ë”°ëœ»í•˜ê²Œ ì½ì–´ì£¼ì„¸ìš”.

ì •í™•í•œ ë¶„ì„ë³´ë‹¤ëŠ” ê³µê°ê³¼ ìœ„ë¡œë¥¼ ë‹´ì€ í•´ì„ì„ í•´ì£¼ì„¸ìš”.`

        userPrompt := `ì´ ê·¸ë¦¼ì„ ë³´ê³  ë‹¤ìŒì„ ë¶„ì„í•´ì£¼ì„¸ìš”:

1. ê·¸ë¦¼ì—ì„œ ëŠê»´ì§€ëŠ” ê°ì • (í•œ ë¬¸ì¥, ì˜ˆ: "í”¼ê³¤í•˜ê³  ìœ„ë¡œë°›ê³  ì‹¶ì€")
2. ì—°ìƒë˜ëŠ” í‚¤ì›Œë“œ 3ê°œ (ìŒì‹ê³¼ ì—°ê´€ì§€ì„ ìˆ˜ ìˆëŠ” ê²ƒë“¤)
3. ë¶„ìœ„ê¸° (bright/calm/dark ì¤‘ í•˜ë‚˜)

ë°˜ë“œì‹œ ì•„ë˜ JSON í˜•ì‹ìœ¼ë¡œë§Œ ì‘ë‹µí•´ì£¼ì„¸ìš”:
{"emotion": "...", "keywords": ["...", "...", "..."], "mood": "..."}`

        if inputText != "" </span><span class="cov0" title="0">{
                userPrompt = fmt.Sprintf(`ì‚¬ìš©ìê°€ ê·¸ë¦¼ê³¼ í•¨ê»˜ ë‹¤ìŒ ë©”ì‹œì§€ë¥¼ ë‚¨ê²¼ìŠµë‹ˆë‹¤: "%s"

%s`, inputText, userPrompt)
        }</span>

        <span class="cov0" title="0">reqBody := map[string]interface{}{
                "system_instruction": map[string]interface{}{
                        "parts": []map[string]string{
                                {"text": systemPrompt},
                        },
                },
                "contents": []map[string]interface{}{
                        {
                                "parts": []map[string]interface{}{
                                        {"text": userPrompt},
                                        {
                                                "inline_data": map[string]string{
                                                        "mime_type": "image/png",
                                                        "data":      base64Image,
                                                },
                                        },
                                },
                        },
                },
                "generationConfig": map[string]interface{}{
                        "temperature":     0.7,
                        "maxOutputTokens": 500,
                },
        }

        respBody, err := c.doRequest(ctx, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze sketch: %w", err)
        }</span>

        <span class="cov0" title="0">content, err := c.extractContent(respBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var result AnalysisResult
        if err := json.Unmarshal([]byte(content), &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse analysis result: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// GenerateRecommendationReason ë©”ë‰´ ì¶”ì²œ ì´ìœ  ìƒì„±
func (c *Client) GenerateRecommendationReason(ctx context.Context, emotion string, keywords []string, menuName string) (string, error) <span class="cov8" title="1">{
        if c.apiKey == "" </span><span class="cov8" title="1">{
                return c.mockReason(emotion, menuName), nil
        }</span>

        <span class="cov0" title="0">prompt := fmt.Sprintf(`ê°ì •: %s
í‚¤ì›Œë“œ: %v

ìœ„ ìƒíƒœì˜ ì‚¬ëŒì—ê²Œ ì–´ìš¸ë¦¬ëŠ” ìŒì‹ìœ¼ë¡œ "%s"ì„ ì¶”ì²œí•©ë‹ˆë‹¤.
ì™œ ì´ ìŒì‹ì´ ì–´ìš¸ë¦¬ëŠ”ì§€ 2ë¬¸ì¥ ì´ë‚´ë¡œ ë”°ëœ»í•˜ê³  ê³µê°ê°€ëŠ” ë¬¸ì²´ë¡œ ì„¤ëª…í•´ì£¼ì„¸ìš”.
ì„¤ëª…ë§Œ ì¶œë ¥í•˜ê³  ë‹¤ë¥¸ í…ìŠ¤íŠ¸ëŠ” í¬í•¨í•˜ì§€ ë§ˆì„¸ìš”.`, emotion, keywords, menuName)

        reqBody := map[string]interface{}{
                "contents": []map[string]interface{}{
                        {
                                "parts": []map[string]string{
                                        {"text": prompt},
                                },
                        },
                },
                "generationConfig": map[string]interface{}{
                        "temperature":     0.8,
                        "maxOutputTokens": 200,
                },
        }

        respBody, err := c.doRequest(ctx, reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate reason: %w", err)
        }</span>

        <span class="cov0" title="0">content, err := c.extractContent(respBody)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// doRequest HTTP ìš”ì²­ ì‹¤í–‰
func (c *Client) doRequest(ctx context.Context, body map[string]interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        jsonBody, err := json.Marshal(body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/models/%s:generateContent?key=%s", c.baseURL, c.model, c.apiKey)
        req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(jsonBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respData, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API error: %s - %s", resp.Status, string(respData))
        }</span>

        <span class="cov0" title="0">var result map[string]interface{}
        if err := json.Unmarshal(respData, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// extractContent Gemini ì‘ë‹µì—ì„œ content ì¶”ì¶œ
func (c *Client) extractContent(resp map[string]interface{}) (string, error) <span class="cov0" title="0">{
        candidates, ok := resp["candidates"].([]interface{})
        if !ok || len(candidates) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no candidates in response")
        }</span>

        <span class="cov0" title="0">candidate := candidates[0].(map[string]interface{})
        content, ok := candidate["content"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no content in candidate")
        }</span>

        <span class="cov0" title="0">parts, ok := content["parts"].([]interface{})
        if !ok || len(parts) == 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no parts in content")
        }</span>

        <span class="cov0" title="0">part := parts[0].(map[string]interface{})
        text, ok := part["text"].(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("no text in part")
        }</span>

        <span class="cov0" title="0">return text, nil</span>
}

// mockAnalysis API í‚¤ê°€ ì—†ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ëª©ì—… ì‘ë‹µ
func (c *Client) mockAnalysis(inputText string) *AnalysisResult <span class="cov8" title="1">{
        if inputText != "" </span><span class="cov8" title="1">{
                return &amp;AnalysisResult{
                        Emotion:  "ë­”ê°€ íŠ¹ë³„í•œ ê²ƒì„ ì›í•˜ëŠ”",
                        Keywords: []string{"ê¸°ëŒ€ê°", "ì„¤ë ˜", "ìƒˆë¡œì›€"},
                        Mood:     "bright",
                }
        }</span>

        <span class="cov8" title="1">return &amp;AnalysisResult{
                Emotion:  "í”¼ê³¤í•˜ê³  ìœ„ë¡œë°›ê³  ì‹¶ì€",
                Keywords: []string{"ë”°ëœ»í•¨", "í¬ê·¼í•¨", "ì§‘ë°¥"},
                Mood:     "calm",
        }</span>
}

// mockReason API í‚¤ê°€ ì—†ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ëª©ì—… ì¶”ì²œ ì´ìœ 
func (c *Client) mockReason(emotion, menuName string) string <span class="cov8" title="1">{
        reasons := map[string]string{
                "ëœì¥ì°Œê°œ":  "ì§€ì¹œ í•˜ë£¨ ëì— ë”°ëœ»í•œ êµ­ë¬¼ í•œ ìˆŸê°ˆì€ ë§ˆìŒê¹Œì§€ ë…¹ì—¬ì¤„ ê±°ì˜ˆìš”. ì—„ë§ˆê°€ ë“ì—¬ì£¼ì‹  ê²ƒ ê°™ì€ ê·¸ ë§›ì´ ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ í•„ìš”í•œ ìœ„ë¡œì˜ˆìš”.",
                "ì¹¼êµ­ìˆ˜":   "ë”°ëˆí•œ ë©´ë°œì´ ì†ì„ í¸í•˜ê²Œ í•´ì¤„ ê±°ì˜ˆìš”. í•œ ê·¸ë¦‡ ë¹„ìš°ê³  ë‚˜ë©´ ë§ˆìŒë„ í•œê²° ê°€ë²¼ì›Œì§ˆ ê±°ì˜ˆìš”.",
                "ê¹€ì¹˜ì°Œê°œ":  "ì¹¼ì¹¼í•œ êµ­ë¬¼ì´ ì •ì‹ ì„ ë²ˆì© ë“¤ê²Œ í•´ì¤„ ê±°ì˜ˆìš”. ë°¥ í•œ ê³µê¸° ëšë”± ë¹„ìš°ê³  ë‚˜ë©´ í™œë ¥ì´ ìƒê¸¸ ê±°ì˜ˆìš”.",
                "ì‚¼ê²¹ì‚´":   "ê³ ê¸° í•œ ì ì˜ í–‰ë³µì´ ì˜¤ëŠ˜ í•˜ë£¨ì˜ í”¼ë¡œë¥¼ ë‚ ë ¤ì¤„ ê±°ì˜ˆìš”. ìŠ¤ìŠ¤ë¡œì—ê²Œ ì£¼ëŠ” ì‘ì€ ì„ ë¬¼ì´ì—ìš”.",
                "ëƒ‰ë©´":    "ì‹œì›í•œ ìœ¡ìˆ˜ê°€ ë³µì¡í•œ ë¨¸ë¦¬ë¥¼ ë§ë”í•˜ê²Œ ì •ë¦¬í•´ì¤„ ê±°ì˜ˆìš”. ì²­ëŸ‰í•œ í•œ ê·¸ë¦‡ì´ ë‹¹ì‹ ì˜ ê¸°ë¶„ì„ ìƒì¾Œí•˜ê²Œ ë°”ê¿”ì¤„ ê±°ì˜ˆìš”.",
                "default": fmt.Sprintf("%s í•œ ê·¸ë¦‡ì´ ì˜¤ëŠ˜ ë‹¹ì‹ ì—ê²Œ ë”± ë§ëŠ” ì„ íƒì´ì—ìš”. ë§›ìˆê²Œ ë“œì‹œê³  í˜ë‚´ì„¸ìš”!", menuName),
        }

        if reason, ok := reasons[menuName]; ok </span><span class="cov8" title="1">{
                return reason
        }</span>
        <span class="cov8" title="1">return reasons["default"]</span>
}

// IsAvailable API í‚¤ê°€ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
func (c *Client) IsAvailable() bool <span class="cov8" title="1">{
        return c.apiKey != ""
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package service

import (
        "context"
        "strings"

        "github.com/ggorockee/ojeomneo/server/internal/model"
        "gorm.io/gorm"
)

// MenuService ë©”ë‰´ ì„œë¹„ìŠ¤
type MenuService struct {
        db *gorm.DB
}

// NewMenuService ìƒˆ ë©”ë‰´ ì„œë¹„ìŠ¤ ìƒì„±
func NewMenuService(db *gorm.DB) *MenuService <span class="cov8" title="1">{
        return &amp;MenuService{db: db}
}</span>

// GetByID IDë¡œ ë©”ë‰´ ì¡°íšŒ
func (s *MenuService) GetByID(ctx context.Context, id uint) (*model.Menu, error) <span class="cov8" title="1">{
        var menu model.Menu
        if err := s.db.WithContext(ctx).First(&amp;menu, id).Error; err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;menu, nil</span>
}

// List ë©”ë‰´ ëª©ë¡ ì¡°íšŒ
func (s *MenuService) List(ctx context.Context, category string, tag string, page, limit int) ([]model.Menu, int64, error) <span class="cov8" title="1">{
        var menus []model.Menu
        var total int64

        query := s.db.WithContext(ctx).Model(&amp;model.Menu{}).Where("is_active = ?", true)

        // ì¹´í…Œê³ ë¦¬ í•„í„°
        if category != "" </span><span class="cov8" title="1">{
                query = query.Where("category = ?", category)
        }</span>

        // íƒœê·¸ í•„í„° (JSONB ë°°ì—´ì—ì„œ ê²€ìƒ‰)
        <span class="cov8" title="1">if tag != "" </span><span class="cov0" title="0">{
                query = query.Where(
                        "emotion_tags @&gt; ?::jsonb OR situation_tags @&gt; ?::jsonb OR attribute_tags @&gt; ?::jsonb",
                        `["`+tag+`"]`, `["`+tag+`"]`, `["`+tag+`"]`,
                )
        }</span>

        // ì „ì²´ ê°œìˆ˜ ì¡°íšŒ
        <span class="cov8" title="1">if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // í˜ì´ì§€ë„¤ì´ì…˜
        <span class="cov8" title="1">offset := (page - 1) * limit
        if err := query.Offset(offset).Limit(limit).Order("name ASC").Find(&amp;menus).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return menus, total, nil</span>
}

// FindByKeywords í‚¤ì›Œë“œì™€ ë§¤ì¹­ë˜ëŠ” ë©”ë‰´ ê²€ìƒ‰
func (s *MenuService) FindByKeywords(ctx context.Context, keywords []string, limit int) ([]model.Menu, error) <span class="cov0" title="0">{
        var menus []model.Menu

        if len(keywords) == 0 </span><span class="cov0" title="0">{
                // í‚¤ì›Œë“œê°€ ì—†ìœ¼ë©´ ëœë¤ ë©”ë‰´ ë°˜í™˜
                if err := s.db.WithContext(ctx).
                        Where("is_active = ?", true).
                        Order("RANDOM()").
                        Limit(limit).
                        Find(&amp;menus).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return menus, nil</span>
        }

        // í‚¤ì›Œë“œ ê¸°ë°˜ íƒœê·¸ ë§¤ì¹­
        // ìœ ì‚¬ì–´ ë§¤í•‘ ì ìš©
        <span class="cov0" title="0">mappedTags := s.mapKeywordsToTags(keywords)

        // íƒœê·¸ ë§¤ì¹­ ì¿¼ë¦¬ (OR ì¡°ê±´)
        query := s.db.WithContext(ctx).Model(&amp;model.Menu{}).Where("is_active = ?", true)

        var conditions []string
        var args []interface{}

        for _, tag := range mappedTags </span><span class="cov0" title="0">{
                jsonTag := `["` + tag + `"]`
                conditions = append(conditions, "emotion_tags @&gt; ?::jsonb OR situation_tags @&gt; ?::jsonb OR attribute_tags @&gt; ?::jsonb")
                args = append(args, jsonTag, jsonTag, jsonTag)
        }</span>

        <span class="cov0" title="0">if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                query = query.Where("("+strings.Join(conditions, " OR ")+")", args...)
        }</span>

        <span class="cov0" title="0">if err := query.Order("RANDOM()").Limit(limit).Find(&amp;menus).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // ë§¤ì¹­ëœ ë©”ë‰´ê°€ ì—†ìœ¼ë©´ ëœë¤ ë°˜í™˜
        <span class="cov0" title="0">if len(menus) == 0 </span><span class="cov0" title="0">{
                if err := s.db.WithContext(ctx).
                        Where("is_active = ?", true).
                        Order("RANDOM()").
                        Limit(limit).
                        Find(&amp;menus).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return menus, nil</span>
}

// mapKeywordsToTags í‚¤ì›Œë“œë¥¼ íƒœê·¸ë¡œ ë§¤í•‘
func (s *MenuService) mapKeywordsToTags(keywords []string) []string <span class="cov8" title="1">{
        // í‚¤ì›Œë“œ â†’ íƒœê·¸ ë§¤í•‘ ì‚¬ì „
        mapping := map[string][]string{
                // ê°ì •/ë¶„ìœ„ê¸° ê´€ë ¨
                "ë”°ëœ»í•¨":  {"ìœ„ë¡œ", "ë”°ëœ»í•œ", "êµ­ë¬¼"},
                "í¬ê·¼í•¨":  {"ìœ„ë¡œ", "ë”°ëœ»í•œ", "ì§‘ë°¥"},
                "ì§‘ë°¥":   {"ìœ„ë¡œ", "í•œì‹", "ì§‘ë°¥"},
                "ì‹œì›í•¨":  {"ì²­ëŸ‰", "ì‹œì›í•œ", "ë©´ë¥˜"},
                "ì²­ëŸ‰":   {"ì²­ëŸ‰", "ì‹œì›í•œ"},
                "ë§¤ì½¤í•¨":  {"ë§¤ìš´", "ìê·¹ì "},
                "í™”ëˆ":   {"ë§¤ìš´", "ìê·¹ì ", "í™œë ¥"},
                "ë‹¬ì½¤í•¨":  {"ë‹¬ì½¤í•œ", "ë³´ìƒ", "ë””ì €íŠ¸"},
                "ë³´ìƒ":   {"ë³´ìƒ", "ë‹¬ì½¤í•œ", "íŠ¹ë³„í•œ"},
                "í”¼ë¡œ":   {"ìœ„ë¡œ", "ë”°ëœ»í•œ", "ë“ ë“ í•œ"},
                "ìŠ¤íŠ¸ë ˆìŠ¤": {"ë§¤ìš´", "ìê·¹ì ", "í™œë ¥"},
                "í–‰ë³µ":   {"ë³´ìƒ", "ë‹¬ì½¤í•œ", "íŠ¹ë³„í•œ"},
                "ìš°ìš¸":   {"ìœ„ë¡œ", "ë”°ëœ»í•œ", "êµ­ë¬¼"},
                "í™œë ¥":   {"í™œë ¥", "ë“ ë“ í•œ", "ê³ ê¸°"},
                "ê°€ë²¼ì›€":  {"ê°€ë²¼ìš´", "ìƒëŸ¬ë“œ", "ê±´ê°•"},
                "ë“ ë“ í•¨":  {"ë“ ë“ í•œ", "ê³ ê¸°", "ë°¥"},
        }

        tagSet := make(map[string]bool)

        for _, keyword := range keywords </span><span class="cov8" title="1">{
                // ì§ì ‘ ë§¤í•‘
                if tags, ok := mapping[keyword]; ok </span><span class="cov8" title="1">{
                        for _, tag := range tags </span><span class="cov8" title="1">{
                                tagSet[tag] = true
                        }</span>
                }
                // í‚¤ì›Œë“œ ìì²´ë„ íƒœê·¸ë¡œ ì¶”ê°€
                <span class="cov8" title="1">tagSet[keyword] = true</span>
        }

        <span class="cov8" title="1">tags := make([]string, 0, len(tagSet))
        for tag := range tagSet </span><span class="cov8" title="1">{
                tags = append(tags, tag)
        }</span>

        <span class="cov8" title="1">return tags</span>
}

// Create ë©”ë‰´ ìƒì„±
func (s *MenuService) Create(ctx context.Context, menu *model.Menu) error <span class="cov8" title="1">{
        return s.db.WithContext(ctx).Create(menu).Error
}</span>

// Update ë©”ë‰´ ìˆ˜ì •
func (s *MenuService) Update(ctx context.Context, menu *model.Menu) error <span class="cov8" title="1">{
        return s.db.WithContext(ctx).Save(menu).Error
}</span>

// Delete ë©”ë‰´ ì‚­ì œ (soft delete)
func (s *MenuService) Delete(ctx context.Context, id uint) error <span class="cov8" title="1">{
        return s.db.WithContext(ctx).Delete(&amp;model.Menu{}, id).Error
}</span>

// GetCategories ëª¨ë“  ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë°˜í™˜
func (s *MenuService) GetCategories() []map[string]string <span class="cov8" title="1">{
        categories := []model.MenuCategory{
                model.MenuCategoryKorean,
                model.MenuCategoryChinese,
                model.MenuCategoryJapanese,
                model.MenuCategoryWestern,
                model.MenuCategoryAsian,
                model.MenuCategorySnack,
                model.MenuCategoryCafe,
                model.MenuCategoryOther,
        }

        result := make([]map[string]string, len(categories))
        for i, cat := range categories </span><span class="cov8" title="1">{
                result[i] = map[string]string{
                        "value": string(cat),
                        "label": cat.Label(),
                }
        }</span>

        <span class="cov8" title="1">return result</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/google/uuid"
        "gorm.io/datatypes"
        "gorm.io/gorm"

        "github.com/ggorockee/ojeomneo/server/internal/model"
        "github.com/ggorockee/ojeomneo/server/internal/service/llm"
)

// SketchService ìŠ¤ì¼€ì¹˜ ì„œë¹„ìŠ¤
type SketchService struct {
        db          *gorm.DB
        llmClient   *llm.Client
        menuService *MenuService
        uploadPath  string
}

// NewSketchService ìƒˆ ìŠ¤ì¼€ì¹˜ ì„œë¹„ìŠ¤ ìƒì„±
func NewSketchService(db *gorm.DB, llmClient *llm.Client, menuService *MenuService) *SketchService <span class="cov0" title="0">{
        uploadPath := os.Getenv("UPLOAD_PATH")
        if uploadPath == "" </span><span class="cov0" title="0">{
                uploadPath = "./uploads"
        }</span>

        // ì—…ë¡œë“œ ë””ë ‰í† ë¦¬ ìƒì„±
        <span class="cov0" title="0">os.MkdirAll(filepath.Join(uploadPath, "sketches"), 0755)

        return &amp;SketchService{
                db:          db,
                llmClient:   llmClient,
                menuService: menuService,
                uploadPath:  uploadPath,
        }</span>
}

// AnalyzeRequest ìŠ¤ì¼€ì¹˜ ë¶„ì„ ìš”ì²­
type AnalyzeRequest struct {
        ImageData []byte
        InputText string
        DeviceID  string
        UserID    *uint
}

// AnalyzeResponse ìŠ¤ì¼€ì¹˜ ë¶„ì„ ì‘ë‹µ
type AnalyzeResponse struct {
        SketchID       uuid.UUID                `json:"sketch_id"`
        Analysis       *llm.AnalysisResult      `json:"analysis"`
        Recommendation *model.RecommendationSet `json:"recommendation"`
        CreatedAt      time.Time                `json:"created_at"`
}

// Analyze ìŠ¤ì¼€ì¹˜ ë¶„ì„ ë° ë©”ë‰´ ì¶”ì²œ
func (s *SketchService) Analyze(ctx context.Context, req *AnalyzeRequest) (*AnalyzeResponse, error) <span class="cov0" title="0">{
        // 1. ì´ë¯¸ì§€ ì €ì¥
        imagePath, err := s.saveImage(req.ImageData, req.DeviceID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save image: %w", err)
        }</span>

        // 2. LLMìœ¼ë¡œ ìŠ¤ì¼€ì¹˜ ë¶„ì„
        <span class="cov0" title="0">analysis, err := s.llmClient.AnalyzeSketch(ctx, req.ImageData, req.InputText)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze sketch: %w", err)
        }</span>

        // 3. ë¶„ì„ ê²°ê³¼ë¥¼ JSONìœ¼ë¡œ ë³€í™˜
        <span class="cov0" title="0">analysisJSON, err := json.Marshal(analysis)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal analysis: %w", err)
        }</span>

        // 4. ìŠ¤ì¼€ì¹˜ ì €ì¥
        <span class="cov0" title="0">sketch := &amp;model.Sketch{
                DeviceID:       req.DeviceID,
                UserID:         req.UserID,
                ImagePath:      imagePath,
                InputText:      req.InputText,
                AnalysisResult: datatypes.JSON(analysisJSON),
        }

        if err := s.db.WithContext(ctx).Create(sketch).Error; err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to save sketch: %w", err)
        }</span>

        // 5. í‚¤ì›Œë“œ ê¸°ë°˜ ë©”ë‰´ ê²€ìƒ‰
        <span class="cov0" title="0">menus, err := s.menuService.FindByKeywords(ctx, analysis.Keywords, 5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find menus: %w", err)
        }</span>

        <span class="cov0" title="0">if len(menus) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no menus found")
        }</span>

        // 6. ì¶”ì²œ ì´ìœ  ìƒì„± ë° ì €ì¥
        <span class="cov0" title="0">recommendations, err := s.createRecommendations(ctx, sketch.ID, analysis, menus)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create recommendations: %w", err)
        }</span>

        // 7. ì‘ë‹µ êµ¬ì„±
        <span class="cov0" title="0">response := &amp;AnalyzeResponse{
                SketchID:  sketch.ID,
                Analysis:  analysis,
                CreatedAt: sketch.CreatedAt,
                Recommendation: &amp;model.RecommendationSet{
                        Primary:      s.toMenuRecommendation(&amp;menus[0], recommendations[0].Reason),
                        Alternatives: s.toAlternatives(menus[1:], recommendations[1:]),
                },
        }

        return response, nil</span>
}

// createRecommendations ì¶”ì²œ ìƒì„± ë° ì €ì¥
func (s *SketchService) createRecommendations(ctx context.Context, sketchID uuid.UUID, analysis *llm.AnalysisResult, menus []model.Menu) ([]model.Recommendation, error) <span class="cov0" title="0">{
        recommendations := make([]model.Recommendation, 0, len(menus))

        for i, menu := range menus </span><span class="cov0" title="0">{
                // LLMìœ¼ë¡œ ì¶”ì²œ ì´ìœ  ìƒì„±
                reason, err := s.llmClient.GenerateRecommendationReason(ctx, analysis.Emotion, analysis.Keywords, menu.Name)
                if err != nil </span><span class="cov0" title="0">{
                        // ì—ëŸ¬ ì‹œ ê¸°ë³¸ ì´ìœ  ì‚¬ìš©
                        reason = fmt.Sprintf("%sì´(ê°€) ì§€ê¸ˆ ë‹¹ì‹ ì—ê²Œ ë”± ë§ëŠ” ì„ íƒì´ì—ìš”!", menu.Name)
                }</span>

                <span class="cov0" title="0">rec := model.Recommendation{
                        SketchID: sketchID,
                        MenuID:   menu.ID,
                        Reason:   reason,
                        Rank:     i + 1,
                }

                if err := s.db.WithContext(ctx).Create(&amp;rec).Error; err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">recommendations = append(recommendations, rec)</span>
        }

        <span class="cov0" title="0">return recommendations, nil</span>
}

// saveImage ì´ë¯¸ì§€ íŒŒì¼ ì €ì¥
func (s *SketchService) saveImage(data []byte, deviceID string) (string, error) <span class="cov0" title="0">{
        filename := fmt.Sprintf("%s_%d.png", deviceID, time.Now().UnixNano())
        relativePath := filepath.Join("sketches", filename)
        fullPath := filepath.Join(s.uploadPath, relativePath)

        if err := os.WriteFile(fullPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return relativePath, nil</span>
}

// toMenuRecommendation Menuë¥¼ MenuRecommendationìœ¼ë¡œ ë³€í™˜
func (s *SketchService) toMenuRecommendation(menu *model.Menu, reason string) *model.MenuRecommendation <span class="cov0" title="0">{
        return &amp;model.MenuRecommendation{
                MenuID:   menu.ID,
                Name:     menu.Name,
                Category: menu.Category,
                ImageURL: menu.ImageURL,
                Reason:   reason,
                Tags:     menu.GetAllTags(),
        }
}</span>

// toAlternatives ëŒ€ì•ˆ ë©”ë‰´ ëª©ë¡ ìƒì„±
func (s *SketchService) toAlternatives(menus []model.Menu, recommendations []model.Recommendation) []model.MenuRecommendation <span class="cov0" title="0">{
        if len(menus) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // ìµœëŒ€ 2ê°œì˜ ëŒ€ì•ˆë§Œ ë°˜í™˜
        <span class="cov0" title="0">limit := 2
        if len(menus) &lt; limit </span><span class="cov0" title="0">{
                limit = len(menus)
        }</span>

        <span class="cov0" title="0">alternatives := make([]model.MenuRecommendation, limit)
        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                alternatives[i] = model.MenuRecommendation{
                        MenuID:   menus[i].ID,
                        Name:     menus[i].Name,
                        Category: menus[i].Category,
                        Reason:   recommendations[i].Reason,
                }
        }</span>

        <span class="cov0" title="0">return alternatives</span>
}

// GetHistory ë””ë°”ì´ìŠ¤ë³„ íˆìŠ¤í† ë¦¬ ì¡°íšŒ
func (s *SketchService) GetHistory(ctx context.Context, deviceID string, page, limit int) ([]model.Sketch, int64, error) <span class="cov0" title="0">{
        var sketches []model.Sketch
        var total int64

        query := s.db.WithContext(ctx).Model(&amp;model.Sketch{}).
                Where("device_id = ?", deviceID)

        if err := query.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * limit
        if err := query.
                Preload("Recommendations").
                Preload("Recommendations.Menu").
                Order("created_at DESC").
                Offset(offset).
                Limit(limit).
                Find(&amp;sketches).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return sketches, total, nil</span>
}

// GetByID IDë¡œ ìŠ¤ì¼€ì¹˜ ì¡°íšŒ
func (s *SketchService) GetByID(ctx context.Context, id uuid.UUID) (*model.Sketch, error) <span class="cov0" title="0">{
        var sketch model.Sketch
        if err := s.db.WithContext(ctx).
                Preload("Recommendations").
                Preload("Recommendations.Menu").
                First(&amp;sketch, "id = ?", id).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;sketch, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
